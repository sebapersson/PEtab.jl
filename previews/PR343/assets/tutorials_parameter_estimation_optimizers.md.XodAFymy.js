import{_ as p,C as r,c as l,o as h,aA as a,j as e,G as t,a as n,w as o}from"./chunks/framework.DLYJsqdg.js";const F=JSON.parse('{"title":"Optimization algorithms and recommendations","description":"","frontmatter":{},"headers":[],"relativePath":"tutorials/parameter_estimation/optimizers.md","filePath":"tutorials/parameter_estimation/optimizers.md","lastUpdated":null}'),d={name:"tutorials/parameter_estimation/optimizers.md"},k={class:"jldocstring custom-block"},c={class:"jldocstring custom-block"};function m(g,i,E,b,u,f){const s=r("Badge");return h(),l("div",null,[i[8]||(i[8]=a(`<h1 id="options_optimizers" tabindex="-1">Optimization algorithms and recommendations <a class="header-anchor" href="#options_optimizers" aria-label="Permalink to &quot;Optimization algorithms and recommendations {#options_optimizers}&quot;">​</a></h1><p>For <a href="/PEtab.jl/previews/PR343/API#PEtab.calibrate"><code>calibrate</code></a> and <a href="/PEtab.jl/previews/PR343/API#PEtab.calibrate_multistart"><code>calibrate_multistart</code></a>, PEtab.jl supports optimizers from three popular packages: <a href="https://github.com/JuliaNLSolvers/Optim.jl" target="_blank" rel="noreferrer">Optim.jl</a>, <a href="https://github.com/jump-dev/Ipopt.jl" target="_blank" rel="noreferrer">Ipopt.jl</a>, and <a href="https://fides-dev.github.io/Fides.jl/stable/" target="_blank" rel="noreferrer">Fides.jl</a>. This page summarizes the available algorithms and provides recommendations by model size.</p><h2 id="Recommended-algorithm" tabindex="-1">Recommended algorithm <a class="header-anchor" href="#Recommended-algorithm" aria-label="Permalink to &quot;Recommended algorithm {#Recommended-algorithm}&quot;">​</a></h2><p>When choosing an optimization algorithm, the <strong>no free lunch</strong> principle applies: performance is problem-dependent and no method is universally best. Still, benchmark studies have identified methods that often work well for ODE models in biology (and likely beyond) [<a href="/PEtab.jl/previews/PR343/references#raue2013lessons">3</a>, <a href="/PEtab.jl/previews/PR343/references#hass2019benchmark">4</a>, <a href="/PEtab.jl/previews/PR343/references#villaverde2019benchmarking">6</a>]. In brief, the choice is driven by model size: for small models an accurate Hessian (or good approximation) is often feasible to compute, while for larger models it typically is not (see <a href="/PEtab.jl/previews/PR343/configuration/derivatives#gradient_support">gradient and Hessian support</a>). Thereby, we recommend:</p><ul><li><p><strong>Small models</strong> (&lt;10 ODEs and &lt;20 estimated parameters): <code>Optim.IPNewton()</code> with the exact Hessian (<code>hessian_method = :ForwardDiff</code> in the <code>PEtabODEProblem</code>).</p></li><li><p><strong>Medium-sized models</strong> (≈10-20 ODEs and &lt;75 estimated parameters): <code>Fides.CustomHessian()</code> with a Gauss-Newton Hessian approximation (<code>hessian_method = :GaussNewton</code> in the <code>PEtabODEProblem</code>). Gauss-Newton often outperforms the (L)BFGS approximation in this regime [<a href="/PEtab.jl/previews/PR343/references#frohlich2022fides">2</a>].</p></li><li><p><strong>Large models</strong> (&gt;20 ODEs or &gt;75 estimated parameters): (L)BFGS methods such as Ipopt or <code>Fides.BFGS</code>.</p></li></ul><h2 id="Fides" tabindex="-1">Fides <a class="header-anchor" href="#Fides" aria-label="Permalink to &quot;Fides {#Fides}&quot;">​</a></h2><p><a href="https://github.com/fides-dev/Fides.jl" target="_blank" rel="noreferrer">Fides.jl</a> is a trust-region Newton method for box-constrained optimization [<a href="/PEtab.jl/previews/PR343/references#frohlich2022fides">2</a>]. It performs particularly well with a Gauss-Newton Hessian approximation, but it also has built-in support for other approximations (e.g., <code>BFGS</code>, <code>SR1</code>; see the Fides <a href="https://fides-dev.github.io/Fides.jl/stable/API/" target="_blank" rel="noreferrer">documentation</a>).</p><p>Fides evaluates the objective, gradient, and Hessian in each iteration, enabling reuse of intermediate quantities. Since the Gauss–Newton Hessian is based on forward sensitivities (which can also be used to compute the gradient), a recommended <code>PEtabODEProblem</code> configuration is:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Fides</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">petab_prob </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> PEtabODEProblem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    model;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    gradient_method </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :ForwardEquations</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    hessian_method </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :GaussNewton</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    reuse_sensitivities </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">res </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> calibrate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    petab_prob, x0, Fides</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CustomHessian</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    options </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> FidesOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(maxiter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Fides solver options are set with <code>FidesOptions</code> (see the Fides <a href="https://fides-dev.github.io/Fides.jl/stable/API/" target="_blank" rel="noreferrer">documentation</a>). Fides also provides built-in Hessian approximations such as <code>BFGS</code>:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">res </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> calibrate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(petab_prob, x0, Fides</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">BFGS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><h2 id="Optim_alg" tabindex="-1">Optim.jl <a class="header-anchor" href="#Optim_alg" aria-label="Permalink to &quot;Optim.jl {#Optim_alg}&quot;">​</a></h2><p>PEtab.jl supports three algorithms from <a href="https://julianlsolvers.github.io/Optim.jl/stable/" target="_blank" rel="noreferrer">Optim.jl</a>: <code>LBFGS</code>, <code>BFGS</code>, and <code>IPNewton</code> (interior-point Newton).</p><p>Solver settings are passed via <code>options = Optim.Options(...)</code> (see the Optim.jl <a href="https://julianlsolvers.github.io/Optim.jl/stable/user/config/#Solver-options" target="_blank" rel="noreferrer">documenation</a> page). For example, to run <code>Optim.LBFGS()</code> for 10_000 iterations:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Optim</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">res </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> calibrate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    petab_prob, x0, Optim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LBFGS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    options </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Optim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Options</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(iterations </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10_000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h2 id="Ipopt" tabindex="-1">Ipopt <a class="header-anchor" href="#Ipopt" aria-label="Permalink to &quot;Ipopt {#Ipopt}&quot;">​</a></h2><p><a href="https://coin-or.github.io/Ipopt/" target="_blank" rel="noreferrer">Ipopt</a> is an interior-point Newton method for nonlinear optimization [<a href="/PEtab.jl/previews/PR343/references#wachter2006implementation">13</a>]. In PEtab.jl, Ipopt can either use the Hessian provided by the <code>PEtabODEProblem</code> or an L-BFGS Hessian approximation via <code>IpoptOptimizer</code>:</p>`,17)),e("details",k,[e("summary",null,[i[0]||(i[0]=e("a",{id:"PEtab.IpoptOptimizer-tutorials-parameter_estimation-optimizers",href:"#PEtab.IpoptOptimizer-tutorials-parameter_estimation-optimizers"},[e("span",{class:"jlbinding"},"PEtab.IpoptOptimizer")],-1)),i[1]||(i[1]=n()),t(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[3]||(i[3]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">IpoptOptimizer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(LBFGS</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Setup the <a href="https://coin-or.github.io/Ipopt/" target="_blank" rel="noreferrer">Ipopt</a> Interior-point Newton method optmizer for parameter estimation.</p><p>Ipopt can be configured to use either the Hessian method from the <code>PEtabODEProblem</code> (<code>LBFGS=false</code>) or an LBFGS scheme (<code>LBFGS=true</code>). For setting other Ipopt options, see <a href="/PEtab.jl/previews/PR343/API#PEtab.IpoptOptions"><code>IpoptOptions</code></a>.</p><p>See also <a href="/PEtab.jl/previews/PR343/API#PEtab.calibrate"><code>calibrate</code></a> and <a href="/PEtab.jl/previews/PR343/API#PEtab.calibrate_multistart"><code>calibrate_multistart</code></a>.</p><p><strong>Description</strong></p><p>Ipopt is an Interior-point Newton method for constrained non-linear optimization problems. More information on the algorithm can be found in [1].</p><ol><li>Wächter and Biegler, Mathematical programming, pp 25-57 (2006)</li></ol>',7)),t(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...i[2]||(i[2]=[e("a",{href:"https://github.com/sebapersson/PEtab.jl/blob/bf828b5935eded0a02c2d99ca466971def172d64/src/structs/parameter_estimation.jl#L1-L19",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i[9]||(i[9]=e("p",null,[n("Ipopt exposes many solver options. A commonly used subset can be set via "),e("code",null,"IpoptOptions"),n(":")],-1)),e("details",c,[e("summary",null,[i[4]||(i[4]=e("a",{id:"PEtab.IpoptOptions-tutorials-parameter_estimation-optimizers",href:"#PEtab.IpoptOptions-tutorials-parameter_estimation-optimizers"},[e("span",{class:"jlbinding"},"PEtab.IpoptOptions")],-1)),i[5]||(i[5]=n()),t(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[7]||(i[7]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">IpoptOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Options for parameter estimation with <code>IpoptOptimizer</code>.</p><p>More details on the options can be found in the Ipopt <a href="https://coin-or.github.io/Ipopt/" target="_blank" rel="noreferrer">documentation</a>.</p><p>See also <a href="/PEtab.jl/previews/PR343/API#PEtab.IpoptOptimizer"><code>IpoptOptimizer</code></a>, <a href="/PEtab.jl/previews/PR343/API#PEtab.calibrate"><code>calibrate</code></a>, and <a href="/PEtab.jl/previews/PR343/API#PEtab.calibrate_multistart"><code>calibrate_multistart</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>print_level = 0</code>: Output verbosity level (valid values are 0 ≤ print_level ≤ 12)</p></li><li><p><code>max_iter = 1000</code>: Maximum number of iterations</p></li><li><p><code>tol = 1e-8</code>: Relative convergence tolerance</p></li><li><p><code>acceptable_tol = 1e-6</code>: Acceptable relative convergence tolerance</p></li><li><p><code>max_wall_time 1e20</code>: Maximum wall time optimization is allowed to run</p></li><li><p><code>acceptable_obj_change_tol 1e20</code>: Acceptance stopping criterion based on objective function change.</p></li></ul>',6)),t(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...i[6]||(i[6]=[e("a",{href:"https://github.com/sebapersson/PEtab.jl/blob/bf828b5935eded0a02c2d99ca466971def172d64/src/structs/parameter_estimation.jl#L24-L44",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i[10]||(i[10]=a(`<p>For example, to run Ipopt for 1000 iterations using the L-BFGS Hessian approximation:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Ipopt</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">res </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> calibrate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    petab_prob, x0, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">IpoptOptimizer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    options </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> IpoptOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(max_iter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>For details and the full option list, see the Ipopt documentation and the original publication [<a href="/PEtab.jl/previews/PR343/references#wachter2006implementation">13</a>].</p><div class="tip custom-block"><p class="custom-block-title">Note</p><p>To use Ipopt, load <a href="https://github.com/jump-dev/Ipopt.jl" target="_blank" rel="noreferrer">Ipopt.jl</a> with <code>using Ipopt</code> before running parameter estimation.</p></div><h2 id="References" tabindex="-1">References <a class="header-anchor" href="#References" aria-label="Permalink to &quot;References {#References}&quot;">​</a></h2><ol><li><p>F. Fröhlich and P. K. Sorger. <em>Fides: Reliable trust-region optimization for parameter estimation of ordinary differential equation models</em>. PLoS computational biology <strong>18</strong>, e1010322 (2022).</p></li><li><p>A. Raue, M. Schilling, J. Bachmann, A. Matteson, M. Schelke, D. Kaschek, S. Hug, C. Kreutz, B. D. Harms, F. J. Theis and others. <em>Lessons learned from quantitative dynamical modeling in systems biology</em>. PloS one <strong>8</strong>, e74335 (2013).</p></li><li><p>H. Hass, C. Loos, E. Raimundez-Alvarez, J. Timmer, J. Hasenauer and C. Kreutz. <em>Benchmark problems for dynamic modeling of intracellular processes</em>. Bioinformatics <strong>35</strong>, 3073–3082 (2019).</p></li><li><p>A. F. Villaverde, F. Fröhlich, D. Weindl, J. Hasenauer and J. R. Banga. <em>Benchmarking optimization methods for parameter estimation in large kinetic models</em>. Bioinformatics <strong>35</strong>, 830–838 (2019).</p></li><li><p>A. Wächter and L. T. Biegler. <em>On the implementation of an interior-point filter line-search algorithm for large-scale nonlinear programming</em>. Mathematical programming <strong>106</strong>, 25–57 (2006).</p></li></ol>`,6))])}const _=p(d,[["render",m]]);export{F as __pageData,_ as default};
