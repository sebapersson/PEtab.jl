<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Available and Recommended Algorithms · PEtab.jl</title><meta name="title" content="Available and Recommended Algorithms · PEtab.jl"/><meta property="og:title" content="Available and Recommended Algorithms · PEtab.jl"/><meta property="twitter:title" content="Available and Recommended Algorithms · PEtab.jl"/><meta name="description" content="Documentation for PEtab.jl."/><meta property="og:description" content="Documentation for PEtab.jl."/><meta property="twitter:description" content="Documentation for PEtab.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom_theme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PEtab.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Extended Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../petab_simcond/">Simulation conditions</a></li><li><a class="tocitem" href="../petab_preeq_simulations/">Steady-State Simulations (Pre-Equilibration)</a></li><li><a class="tocitem" href="../petab_event/">Events (callbacks, dosages, etc.)</a></li><li><a class="tocitem" href="../petab_cond_specific/">Simulation Condition-Specific Parameters</a></li><li><a class="tocitem" href="../petab_obs_noise/">Noise and Observable Parameters</a></li><li><a class="tocitem" href="../import_petab/">Importing PEtab Standard Format</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Parameter Estimation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../pest_method/">Parameter Estimation Methods</a></li><li><a class="tocitem" href="../pest_plot/">Plotting Estimation Results</a></li><li class="is-active"><a class="tocitem" href>Available and Recommended Algorithms</a><ul class="internal"><li><a class="tocitem" href="#Recommended-Optimization-Algorithm"><span>Recommended Optimization Algorithm</span></a></li><li><a class="tocitem" href="#Optim_alg"><span>Optim.jl</span></a></li><li><a class="tocitem" href="#Ipopt"><span>Ipopt</span></a></li><li><a class="tocitem" href="#Fides"><span>Fides</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../pest_select/">Model Selection with PEtab-select</a></li><li><a class="tocitem" href="../pest_custom/">Wrapping Optimization Packages</a></li></ul></li><li><a class="tocitem" href="../inference/">Bayesian Inference</a></li><li><a class="tocitem" href="../API/">API</a></li><li><a class="tocitem" href="../grad_hess_methods/">Gradient and Hessian Methods</a></li><li><a class="tocitem" href="../default_options/">Default Options</a></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Performance Tips</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../nonstiff_models/">Non-Biology (Non-Stiff) Models</a></li><li><a class="tocitem" href="../Beer/">Condition-Specific Parameters</a></li><li><a class="tocitem" href="../Bachmann/">Adjoint Sensitivity Analysis (Large Models)</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li><li><a class="tocitem" href="../FAQ/">FAQ</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Parameter Estimation</a></li><li class="is-active"><a href>Available and Recommended Algorithms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Available and Recommended Algorithms</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/sebapersson/PEtab.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/sebapersson/PEtab.jl/blob/main/docs/src/pest_algs.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="options_optimizers"><a class="docs-heading-anchor" href="#options_optimizers">Available and Recommended Optimization Algorithms</a><a id="options_optimizers-1"></a><a class="docs-heading-anchor-permalink" href="#options_optimizers" title="Permalink"></a></h1><p>For the <code>calibrate</code> and <code>calibrate_multistart</code> functions, PEtab.jl supports optimization algorithms from several popular optimization packages: <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a>, <a href="https://github.com/jump-dev/Ipopt.jl">Ipopt.jl</a>, and <a href="https://github.com/fides-dev/fides">Fides.py</a>. This page provides information on each package, as well as recommendations.</p><h2 id="Recommended-Optimization-Algorithm"><a class="docs-heading-anchor" href="#Recommended-Optimization-Algorithm">Recommended Optimization Algorithm</a><a id="Recommended-Optimization-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Recommended-Optimization-Algorithm" title="Permalink"></a></h2><p>When choosing an optimization algorithm, it is important to keep the <strong>no free lunch</strong> principle in mind: while an algorithm may work well for one problem, there is no universally best method. Nevertheless, benchmark studies have identified algorithms that often perform well for ODE models in biology (and likely beyond) [<a href="../references/#raue2013lessons">2</a>, <a href="../references/#hass2019benchmark">3</a>, <a href="../references/#villaverde2019benchmarking">5</a>]. In particular, the best algorithm to use depends on the size of the parameter estimation problem. This is because the problem considered here is a non-linear continuous optimization problem, and for such problems, having access to a good Hessian approximation improves performance. And, the problem size dictates which type of Hessian approximation can be computed (see this <a href="../grad_hess_methods/#gradient_support">page</a> for more details). Following this, we recommend:</p><ul><li>For <strong>small</strong> models (fewer than 10 ODEs and fewer than 20 parameters to estimate) where computing the Hessian is often computationally feasible, the <code>IPNewton()</code> method from Optim.jl.</li><li>For <strong>medium sized</strong> models (roughly more than 10 ODEs and fewer than 75 parameters), where a Gauss-Newton Hessian can be computed, Fides. The Gauss-Newton Hessian approximation typically outperforms the more common (L)-BFGS approximation, and benchmarks have shown that Fides performs well with such a Hessian approximation [<a href="../references/#frohlich2022fides">1</a>]. If Fides is difficult to install, <code>Optim.BFGS</code> also performs well.</li><li>For <strong>large</strong> models (more than 20 ODEs and more than 75 parameters to estimate), where a Gauss-Newton approximation is too computationally expensive, a (L)-BFGS optimizer is recommended, such as Ipopt or <code>Optim.BFGS</code>.</li></ul><h2 id="Optim_alg"><a class="docs-heading-anchor" href="#Optim_alg">Optim.jl</a><a id="Optim_alg-1"></a><a class="docs-heading-anchor-permalink" href="#Optim_alg" title="Permalink"></a></h2><p>PEtab.jl supports three optimization algorithms from <a href="https://julianlsolvers.github.io/Optim.jl/stable/">Optim.jl</a>: <code>LBFGS</code>, <code>BFGS</code>, and <code>IPNewton</code> (Interior-point Newton). Options for these algorithms can be specified via <code>Optim.Options()</code>, and a complete list of options can be found <a href="https://julianlsolvers.github.io/Optim.jl/v0.9.3/user/config/">here</a>. For example, to use <code>LBFGS</code> with 10,000 iterations, do:</p><pre><code class="language-julia hljs">using Optim
res = calibrate(petab_prob, x0, Optim.LBFGS();
                options=Optim.Options(iterations = 10000))</code></pre><p>If no options are provided, the default ones are used:</p><pre><code class="language-julia hljs">Optim.Options(iterations = 1000,
              show_trace = false,
              allow_f_increases = true,
              successive_f_tol = 3,
              f_tol = 1e-8,
              g_tol = 1e-6,
              x_tol = 0.0)</code></pre><p>For more details on each algorithm and tunable options, see the Optim.jl <a href="https://julianlsolvers.github.io/Optim.jl/stable/">documentation</a>.</p><h2 id="Ipopt"><a class="docs-heading-anchor" href="#Ipopt">Ipopt</a><a id="Ipopt-1"></a><a class="docs-heading-anchor-permalink" href="#Ipopt" title="Permalink"></a></h2><p><a href="https://coin-or.github.io/Ipopt/">Ipopt</a> is an Interior-point Newton method for nonlinear optimization [<a href="../references/#wachter2006implementation">10</a>]. In PEtab.jl, Ipopt can be configured to either use the Hessian from the <code>PEtabODEProblem</code> or a LBFGS Hessian approximation through the <code>IpoptOptimizer</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.IpoptOptimizer-pest_algs" href="#PEtab.IpoptOptimizer-pest_algs"><code>PEtab.IpoptOptimizer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IpoptOptimizer(LBFGS::Bool)</code></pre><p>Setup the <a href="https://coin-or.github.io/Ipopt/">Ipopt</a> Interior-point Newton method optmizer for parameter estimation.</p><p>Ipopt can be configured to use either the Hessian method from the <code>PEtabODEProblem</code> (<code>LBFGS=false</code>) or an LBFGS scheme (<code>LBFGS=true</code>). For setting other Ipopt options, see <a href="../API/#PEtab.IpoptOptions"><code>IpoptOptions</code></a>.</p><p>See also <a href="../API/#PEtab.calibrate"><code>calibrate</code></a> and <a href="../API/#PEtab.calibrate_multistart"><code>calibrate_multistart</code></a>.</p><p><strong>Description</strong></p><p>Ipopt is an Interior-point Newton method for constrained non-linear optimization problems. More information on the algorithm can be found in [1].</p><ol><li>Wächter and Biegler, Mathematical programming, pp 25-57 (2006)</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/c52c8b84a11b212f7570eca93765bb968da70c17/src/structs/parameter_estimation.jl#L49-L67">source</a></section></article><p>Ipopt offers a wide range of options (perhaps too many, in the words of the authors). A subset of these options can be specified using <code>IpoptOptions</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.IpoptOptions-pest_algs" href="#PEtab.IpoptOptions-pest_algs"><code>PEtab.IpoptOptions</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IpoptOptions(; kwargs...)</code></pre><p>Options for parameter estimation with <code>IpoptOptimizer</code>.</p><p>More details on the options can be found in the Ipopt <a href="https://coin-or.github.io/Ipopt/">documentation</a>.</p><p>See also <a href="../API/#PEtab.IpoptOptimizer"><code>IpoptOptimizer</code></a>, <a href="../API/#PEtab.calibrate"><code>calibrate</code></a>, and <a href="../API/#PEtab.calibrate_multistart"><code>calibrate_multistart</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>print_level = 0</code>: Output verbosity level (valid values are 0 ≤ print_level ≤ 12)</li><li><code>max_iter = 1000</code>: Maximum number of iterations</li><li><code>tol = 1e-8</code>: Relative convergence tolerance</li><li><code>acceptable_tol = 1e-6</code>: Acceptable relative convergence tolerance</li><li><code>max_wall_time 1e20</code>: Maximum wall time optimization is allowed to run</li><li><code>acceptable_obj_change_tol 1e20</code>: Acceptance stopping criterion based on objective   function change.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/c52c8b84a11b212f7570eca93765bb968da70c17/src/structs/parameter_estimation.jl#L72-L92">source</a></section></article><p>For example, to use Ipopt with 10,000 iterations and the LBFGS Hessian approximation, do:</p><pre><code class="language-julia hljs">using Ipopt
res = calibrate(petab_prob, x0, IpoptOptimizer(true); 
                options=IpoptOptions(max_iter = 10000))</code></pre><p>For more information on Ipopt and its available options, see the Ipopt <a href="https://coin-or.github.io/Ipopt/">documentation</a> and the original publication [<a href="../references/#wachter2006implementation">10</a>].</p><div class="admonition is-info" id="Note-29fd913e6178a2e3"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-29fd913e6178a2e3" title="Permalink"></a></header><div class="admonition-body"><p>To use Ipopt, the <a href="https://github.com/jump-dev/Ipopt.jl">Ipopt.jl</a> package must be loaded with <code>using Ipopt</code> before running parameter estimation.</p></div></div><h2 id="Fides"><a class="docs-heading-anchor" href="#Fides">Fides</a><a id="Fides-1"></a><a class="docs-heading-anchor-permalink" href="#Fides" title="Permalink"></a></h2><p><a href="https://github.com/fides-dev/fides">Fides.py</a> is a trust-region Newton method designed for box-constrained optimization problems [<a href="../references/#frohlich2022fides">1</a>]. It is particularly efficient when the Hessian is approximated using the <a href="https://en.wikipedia.org/wiki/Gauss%E2%80%93Newton_algorithm">Gauss-Newton</a> method.</p><p>The only drawback with Fides is that it is a Python package, but fortunately, it can be used from PEtab.jl through PyCall. To this end, you must build PyCall with a Python environment that has Fides installed:</p><pre><code class="language-julia hljs">using PyCall
# Path to Python executable with Fides installed
path_python_exe = &quot;path_python&quot;
ENV[&quot;PYTHON&quot;] = path_python_exe
# Build PyCall with the Fides Python environment
import Pkg
Pkg.build(&quot;PyCall&quot;)</code></pre><p>Fides supports several Hessian approximations, which can be specified in the <code>Fides</code> constructor:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.Fides-pest_algs" href="#PEtab.Fides-pest_algs"><code>PEtab.Fides</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Fides(hessian_method; verbose::Bool=false)</code></pre><p>Setup the <a href="https://github.com/fides-dev/fides">Fides</a> box-constrained Newton-trust region optimizer for parameter estimation.</p><p>See also <a href="../API/#PEtab.calibrate"><code>calibrate</code></a> and <a href="../API/#PEtab.calibrate_multistart"><code>calibrate_multistart</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>hessian_method</code>: Method for computing the Hessian. Allowed options are:<ul><li><code>nothing</code>: The Hessian computed by the <code>PEtabODEProblem</code> is used.</li><li><code>:BB</code>: Broyden&#39;s &quot;bad&quot; method.</li><li><code>:BFGS</code>: Broyden-Fletcher-Goldfarb-Shanno update strategy.</li><li><code>:BG</code>: Broyden&#39;s &quot;good&quot; method.</li><li><code>:Broyden</code>: Broyden-class update scheme.</li><li><code>:SR1</code>: Symmetric Rank 1 update.</li><li><code>:SSM</code>: Structured Secant Method.</li><li><code>:TSSM</code>: Totally Structured Secant Method.</li></ul></li><li><code>verbose</code>: Whether to print progress during the parameter estimation.</li></ul><p><strong>Description</strong></p><p>Fides is a Newton-trust region optimizer for box-constrained optmization problems. More information on the algorithm can be found in [1]. Fides particularly excels when the full Hessian is too computationally expensive to compute, but a Gauss-Newton Hessian approximation can be computed (for more details see the documentation). In addition to supporting user Hessians via the <code>PEtabODEProblem</code>, it supports several Hessian approximation methods. Aa more extensive description than above see the Fides <a href="https://github.com/fides-dev/fides">documentation</a>.</p><ol><li>Fröhlich and Sorger, PLoS computational biology, pp e1010322 (2022)</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/c52c8b84a11b212f7570eca93765bb968da70c17/src/structs/parameter_estimation.jl#L1-L32">source</a></section></article><p>A notable feature of Fides is that in each optimization step, the objective, gradient, and Hessian are computed simultaneously. This opens up the possibility for efficient reuse of computed quantities, especially when the Hessian is computed via the Gauss-Newton approximation. Because, to compute the Gauss-Newton Hessian the forward sensitivities are used, which can also be used to compute the gradient. Hence, a good <code>PEtabODEProblem</code> configuration for Fides with Gauss-Newton is:</p><pre><code class="language-julia hljs">petab_prob = PEtabODEProblem(model; gradient_method = :ForwardEquations, 
                             hessian_method = :GaussNewton,
                             reuse_sensitivities = true)</code></pre><p>Given this setup, the Hessian method from the <code>PEtabODEProblem</code> can be used to run Fides for 200 iterations with:</p><pre><code class="language-julia hljs">using PyCall
res = calibrate(petab_prob, x0, Fides(nothing);
                options=py&quot;{&#39;maxiter&#39; : 1000}&quot;)</code></pre><p>As noted above, for Fides options are specified using a Python dictionary. Available options and their default values can be found in the Fides <a href="https://fides-optimizer.readthedocs.io/en/latest/generated/fides.constants.html">documentation</a>, and more information on the algorithm can be found in the original publication [<a href="../references/#frohlich2022fides">1</a>].</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><div class="citation noncanonical"><dl><dt>[1]</dt><dd><div>F. Fröhlich and P. K. Sorger. <em>Fides: Reliable trust-region optimization for parameter estimation of ordinary differential equation models</em>. PLoS computational biology <strong>18</strong>, e1010322 (2022).</div></dd><dt>[2]</dt><dd><div>A. Raue, M. Schilling, J. Bachmann, A. Matteson, M. Schelke, D. Kaschek, S. Hug, C. Kreutz, B. D. Harms, F. J. Theis and others. <em>Lessons learned from quantitative dynamical modeling in systems biology</em>. PloS one <strong>8</strong>, e74335 (2013).</div></dd><dt>[3]</dt><dd><div>H. Hass, C. Loos, E. Raimundez-Alvarez, J. Timmer, J. Hasenauer and C. Kreutz. <em>Benchmark problems for dynamic modeling of intracellular processes</em>. Bioinformatics <strong>35</strong>, 3073–3082 (2019).</div></dd><dt>[5]</dt><dd><div>A. F. Villaverde, F. Fröhlich, D. Weindl, J. Hasenauer and J. R. Banga. <em>Benchmarking optimization methods for parameter estimation in large kinetic models</em>. Bioinformatics <strong>35</strong>, 830–838 (2019).</div></dd><dt>[10]</dt><dd><div>A. Wächter and L. T. Biegler. <em>On the implementation of an interior-point filter line-search algorithm for large-scale nonlinear programming</em>. Mathematical programming <strong>106</strong>, 25–57 (2006).</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../pest_plot/">« Plotting Estimation Results</a><a class="docs-footer-nextpage" href="../pest_select/">Model Selection with PEtab-select »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Saturday 5 July 2025 08:01">Saturday 5 July 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
