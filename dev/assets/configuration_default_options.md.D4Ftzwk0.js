import{_ as e,o as i,c as a,aA as t}from"./chunks/framework.BOAOuvAy.js";const c=JSON.parse('{"title":"Default PEtabODEProblem options","description":"","frontmatter":{},"headers":[],"relativePath":"configuration/default_options.md","filePath":"configuration/default_options.md","lastUpdated":null}'),n={name:"configuration/default_options.md"};function l(r,s,o,d,p,h){return i(),a("div",null,[...s[0]||(s[0]=[t(`<h1 id="default_options" tabindex="-1">Default PEtabODEProblem options <a class="header-anchor" href="#default_options" aria-label="Permalink to &quot;Default PEtabODEProblem options {#default_options}&quot;">​</a></h1><p>A <code>PEtabODEProblem</code> supports multiple gradient/Hessian computation methods and the ODE solvers from <a href="https://github.com/SciML/OrdinaryDiffEq.jl" target="_blank" rel="noreferrer">OrdinaryDiffEq.jl</a>. This leads to many valid <code>PEtabODEProblem</code> configurations, and to simplify usage, default options are provided based on an extensive benchmark study [<a href="/PEtab.jl/dev/references#persson2025petab">1</a>]. This page summarizes these defaults.</p><p>In brief, defaults depend primarily by model size (number of ODEs and number of estimated parameters), since ODE solver performance and especially gradient-computation methods depend strongly on problem size.</p><div class="tip custom-block"><p class="custom-block-title">Non-stiff models</p><p>Defaults are tuned for biological, typically stiff models. For non-stiff models, see <a href="/PEtab.jl/dev/performance/none_stiff#nonstiff_models">Speeding up non-stiff models</a>.</p></div><h2 id="Small-models-20-parameters-and-15-ODEs" tabindex="-1">Small models (≤20 parameters and ≤15 ODEs) <a class="header-anchor" href="#Small-models-20-parameters-and-15-ODEs" aria-label="Permalink to &quot;Small models (≤20 parameters and ≤15 ODEs) {#Small-models-20-parameters-and-15-ODEs}&quot;">​</a></h2><p>The default configuration for small models is:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">petab_prob </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> PEtabODEProblem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    model;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    odesolver </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ODESolver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Rodas5P</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    gradient_method </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :ForwardDiff</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    hessian_method </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :ForwardDiff</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>The rationale is:</p><ul><li><p><strong>ODE solver:</strong> For small stiff models, the Rosenbrock solver <code>Rodas5P()</code> is typically fast, robust (rare with simulation failures), and accurate. Julia’s BDF solvers (e.g. <code>QNDF()</code>) can also work well, but are often less robust.</p></li><li><p><strong>Gradient method:</strong> Forward-mode automatic differentiation via <a href="https://github.com/JuliaDiff/ForwardDiff.jl" target="_blank" rel="noreferrer">ForwardDiff.jl</a> is the fastest option for small models, often faster than sensitivity-equation approaches implemented in tools such as AMICI. Performance can sometimes be improved by tuning the ForwardDiff chunk size, but the optimal value is model-dependent.</p></li><li><p><strong>Hessian method:</strong> Computing the full Hessian with <a href="https://github.com/JuliaDiff/ForwardDiff.jl" target="_blank" rel="noreferrer">ForwardDiff.jl</a> is often feasible for small models, and access to the full Hessian typically improves parameter estimation performance.</p></li></ul><h2 id="Medium-sized-models-75-parameters-and-75-ODEs" tabindex="-1">Medium-sized models (≤75 parameters and ≤75 ODEs) <a class="header-anchor" href="#Medium-sized-models-75-parameters-and-75-ODEs" aria-label="Permalink to &quot;Medium-sized models (≤75 parameters and ≤75 ODEs) {#Medium-sized-models-75-parameters-and-75-ODEs}&quot;">​</a></h2><p>The default configuration for medium-sized models is:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">petab_prob </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> PEtabODEProblem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    model;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    odesolver </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ODESolver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">QNDF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    gradient_method </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :ForwardDiff</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    hessian_method </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :GaussNewton</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>The rationale is:</p><ul><li><p><strong>ODE solver:</strong> For medium-sized stiff models, multi-step BDF solvers such as <code>QNDF()</code> are often faster than Rosenbrock solvers [<a href="/PEtab.jl/dev/references#persson2025petab">1</a>, <a href="/PEtab.jl/dev/references#stadter2021benchmarking">19</a>]. Note, for models with many events, BDF solvers are often slow and in such cases <code>KenCarp4()</code> is a reliable alternative.</p></li><li><p><strong>Gradient method:</strong> Forward-mode automatic differentiation via <a href="https://github.com/JuliaDiff/ForwardDiff.jl" target="_blank" rel="noreferrer">ForwardDiff.jl</a> is typically the most fasest choice in this regime.</p></li><li><p><strong>Hessian method:</strong> Computing the full Hessian with <a href="https://github.com/JuliaDiff/ForwardDiff.jl" target="_blank" rel="noreferrer">ForwardDiff.jl</a> is often too expensive. A Gauss–Newton approximation is usually a good compromise and often outperforms (L)BFGS approximations in practice [<a href="/PEtab.jl/dev/references#persson2025petab">1</a>, <a href="/PEtab.jl/dev/references#frohlich2022fides">2</a>].</p></li></ul><div class="tip custom-block"><p class="custom-block-title">Reusing sensitivities</p><p>For optimizers that evaluate gradient and Gauss-Newton Hessian together (e.g. Fides.jl), setting <code>gradient_method = :ForwardEquations</code> with <code>reuse_sensitivities = true</code> will reduce runtime. See Fides.jl in <a href="/PEtab.jl/dev/tutorials/parameter_estimation/optimizers#options_optimizers">Optimization algorithms and recommendations</a> for details.</p></div><h2 id="Large-models-75-parameters-or-75-ODEs" tabindex="-1">Large models (≥75 parameters or ≥75 ODEs) <a class="header-anchor" href="#Large-models-75-parameters-or-75-ODEs" aria-label="Permalink to &quot;Large models (≥75 parameters or ≥75 ODEs) {#Large-models-75-parameters-or-75-ODEs}&quot;">​</a></h2><p>Defaults are provided for large models, but benchmarking is strongly recommended since solver choice and gradient configuration can strongly affect runtime. Still, the default configuration is:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">petab_prob </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> PEtabODEProblem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    model;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    odesolver </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ODESolver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CVODE_BDF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    gradient_method </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :Adjoint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sensealg </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> InterpolatingAdjoint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(autojacvec </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ReverseDiffVJP</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>The rationale is:</p><ul><li><p><strong>ODE solver:</strong> Large stiff models often benefit from solvers and linear algebra tailored for scale. Benchmark <code>QNDF()</code>, <code>FBDF()</code>, <code>KenCarp4()</code>, and <code>CVODE_BDF()</code>. Also consider enabling sparse Jacobians (<code>sparse_jacobian = true</code>) and trying alternative linear solvers (e.g. <code>CVODE_BDF(linsolve = :KLU)</code>). For guidance, see the DifferentialEquations.jl documentation.</p></li><li><p><strong>Gradient method:</strong> Adjoint sensitivities (<code>gradient_method = :Adjoint</code>) are typically the most efficient choice at this scale. PEtab.jl supports <code>InterpolatingAdjoint</code>, <code>GaussAdjoint</code>, and <code>QuadratureAdjoint</code> from <a href="https://github.com/SciML/SciMLSensitivity.jl" target="_blank" rel="noreferrer">SciMLSensitivity.jl</a>. The default is <code>InterpolatingAdjoint(autojacvec = ReverseDiffVJP())</code>, but different adjoint algorithms and <code>autojacvec</code> options can perform very differently and should be benchmarked.</p></li><li><p><strong>Hessian method:</strong> Computing Gauss–Newton or full Hessians is usually too expensive for large models. In practice, (L)BFGS approximations are often the best option and are supported by common optimizers (e.g. Optim.jl, Ipopt.jl, and Fides.jl).</p></li></ul><h2 id="References" tabindex="-1">References <a class="header-anchor" href="#References" aria-label="Permalink to &quot;References {#References}&quot;">​</a></h2><ol><li><p>S. Persson, F. Fröhlich, S. Grein, T. Loman, D. Ognissanti, V. Hasselgren, J. Hasenauer and M. Cvijovic. <em>PEtab. jl: advancing the efficiency and utility of dynamic modelling</em>. Bioinformatics <strong>41</strong>, btaf497 (2025).</p></li><li><p>F. Fröhlich and P. K. Sorger. <em>Fides: Reliable trust-region optimization for parameter estimation of ordinary differential equation models</em>. PLoS computational biology <strong>18</strong>, e1010322 (2022).</p></li><li><p>P. Städter, Y. Schälte, L. Schmiester, J. Hasenauer and P. L. Stapor. <em>Benchmarking of numerical integration methods for ODE models of biological systems</em>. Scientific reports <strong>11</strong>, 2696 (2021).</p></li></ol>`,22)])])}const m=e(n,[["render",l]]);export{c as __pageData,m as default};
