<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · PEtab.jl</title><meta name="title" content="API · PEtab.jl"/><meta property="og:title" content="API · PEtab.jl"/><meta property="twitter:title" content="API · PEtab.jl"/><meta name="description" content="Documentation for PEtab.jl."/><meta property="og:description" content="Documentation for PEtab.jl."/><meta property="twitter:description" content="Documentation for PEtab.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom_theme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PEtab.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Extended Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../petab_simcond/">Simulation conditions</a></li><li><a class="tocitem" href="../petab_preeq_simulations/">Steady-State Simulations (Pre-Equilibration)</a></li><li><a class="tocitem" href="../petab_event/">Events (callbacks, dosages, etc.)</a></li><li><a class="tocitem" href="../petab_cond_specific/">Simulation Condition-Specific Parameters</a></li><li><a class="tocitem" href="../petab_obs_noise/">Noise and Observable Parameters</a></li><li><a class="tocitem" href="../import_petab/">Importing PEtab Standard Format</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Parameter Estimation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../pest_method/">Parameter Estimation Methods</a></li><li><a class="tocitem" href="../pest_plot/">Plotting Estimation Results</a></li><li><a class="tocitem" href="../pest_algs/">Available and Recommended Algorithms</a></li><li><a class="tocitem" href="../pest_select/">Model Selection with PEtab-select</a></li><li><a class="tocitem" href="../pest_custom/">Wrapping Optimization Packages</a></li></ul></li><li><a class="tocitem" href="../inference/">Bayesian Inference</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#PEtabModel"><span>PEtabModel</span></a></li><li><a class="tocitem" href="#PEtabODEProblem"><span>PEtabODEProblem</span></a></li><li><a class="tocitem" href="#Parameter-Estimation"><span>Parameter Estimation</span></a></li><li><a class="tocitem" href="#Bayesian-Inference"><span>Bayesian Inference</span></a></li></ul></li><li><a class="tocitem" href="../grad_hess_methods/">Gradient and Hessian Methods</a></li><li><a class="tocitem" href="../default_options/">Default Options</a></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Performance Tips</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../nonstiff_models/">Non-Biology (Non-Stiff) Models</a></li><li><a class="tocitem" href="../Beer/">Condition-Specific Parameters</a></li><li><a class="tocitem" href="../Bachmann/">Adjoint Sensitivity Analysis (Large Models)</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li><li><a class="tocitem" href="../FAQ/">FAQ</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/sebapersson/PEtab.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/sebapersson/PEtab.jl/blob/main/docs/src/API.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">PEtab.jl API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="PEtabModel"><a class="docs-heading-anchor" href="#PEtabModel">PEtabModel</a><a id="PEtabModel-1"></a><a class="docs-heading-anchor-permalink" href="#PEtabModel" title="Permalink"></a></h2><p>A <code>PEtabModel</code> for parameter estimation/inference can be created by importing a PEtab parameter estimation problem in the <a href="https://petab.readthedocs.io/en/latest/">standard format</a>, or it can be directly defined in Julia. For the latter, observables that link the model to measurement data are provided by <code>PEtabObservable</code>, parameters to estimate are defined by <code>PEtabParameter</code>, and any potential events (callbacks) are specified as <code>PEtabEvent</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.PEtabObservable" href="#PEtab.PEtabObservable"><code>PEtab.PEtabObservable</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PEtabObservable(obs_formula, noise_formula; kwargs...)</code></pre><p>Formulas defining the likelihood that links the model output to the measurement data.</p><p><code>obs_formula</code> describes how the model output relates to the measurement data, while <code>noise_formula</code> describes the standard deviation (measurement error) and can be an equation or a numerical value. Both the observable and noise formulas can be a valid Julia equation. Variables used in these formulas must be either model species, model parameters, or parameters defined as <code>PEtabParameter</code>. The formulas can also include time-point-specific noise and observable parameters; for more information, see the documentation.</p><p><strong>Keyword Argument</strong></p><ul><li><code>transformation</code>: The transformation applied to the observable and its corresponding   measurements. Valid options are <code>:lin</code> (normal measurement noise), <code>:log</code>, <code>log2</code> or   <code>:log10</code> (log-normal measurement noise). See below for more details.</li></ul><p><strong>Description</strong></p><p>For a measurement <code>y</code>, an observable <code>h = obs_formula</code>, and a standard deviation <code>σ = noise_formula</code>, the <code>PEtabObservable</code> defines the likelihood that links the model output to the measurement data: <span>$\pi(y \mid h, \sigma)$</span>. For <code>transformation = :lin</code>, the measurement noise is assumed to be normally distributed, and the likelihood is given by:</p><p class="math-container">\[\pi(y|h, \sigma) = \frac{1}{\sqrt{2\pi \sigma^2}}\mathrm{exp}\bigg( -\frac{(y - h)^2}{2\sigma^2} \bigg)\]</p><p>As a special case, if <span>$\sigma = 1$</span>, this likelihood reduces to the least-squares objective function. For <code>transformation = :log</code>, the measurement noise is assumed to be log-normally distributed, and the likelihood is given by:</p><p class="math-container">\[\pi(y|h, \sigma) = \frac{1}{\sqrt{2\pi \sigma^2 y^2}}\mathrm{exp}\bigg( -\frac{\big(\mathrm{log}(y) - \mathrm{log}(h)\big)^2}{2\sigma^2} \bigg)\]</p><p>For <code>transformation = :log10</code>, the measurement noise is assumed to be log10-normally distributed, and the likelihood is given by:</p><p class="math-container">\[\pi(y|h, \sigma) = \frac{1}{\sqrt{2\pi \sigma^2 y^2}\mathrm{log}(10) }\mathrm{exp}\bigg( -\frac{\big(\mathrm{log}_{10}(y) - \mathrm{log}_{10}(h)\big)^2}{2\sigma^2} \bigg)\]</p><p>Lastly, for <code>transformation = :log2</code>, the measurement noise is assumed to be log2-normally distributed, and the likelihood is given by:</p><p class="math-container">\[\pi(y|h, \sigma) = \frac{1}{\sqrt{2\pi \sigma^2 y^2}\mathrm{log}(2) }\mathrm{exp}\bigg( -\frac{\big(\mathrm{log}_{2}(y) - \mathrm{log}_{2}(h)\big)^2}{2\sigma^2} \bigg)\]</p><p>For numerical stabillity, PEtab.jl works with the log-likelihood in practice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/60b721a7804035b6fc9c53163fba622f91aa9261/src/structs/petab_model.jl#L64-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.PEtabParameter" href="#PEtab.PEtabParameter"><code>PEtab.PEtabParameter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PEtabParameter(x; kwargs...)</code></pre><p>Parameter estimation information for parameter <code>x</code>.</p><p>All parameters to be estimated in a <code>PEtabODEProblem</code> must be declared as a <code>PEtabParameter</code>, and <code>x</code> must be the name of a parameter that appears in the model, observable formula, or noise formula.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>lb::Float64 = 1e-3</code>: The lower parameter bound for parameter estimation. Must    be specified on the linear scale. For example, if <code>scale = :log10</code>, provide the    bound as <code>1e-3</code> rather than <code>log10(1e-3)</code>.</li><li><code>ub::Float64 = 1e3</code>: The upper parameter bound for parameter estimation. Must as for    <code>lb</code> be provided on linear scale.</li><li><code>scale::Symbol = :log10</code>: The scale on which to estimate the parameter. Allowed options   are <code>:log10</code> (default), <code>:log2</code> <code>:log</code>, and <code>:lin</code>. Estimating on the <code>log10</code>   scale typically improves performance and is recommended.</li><li><code>prior = nothing</code>: An optional continuous univariate parameter prior distribution from   <a href="https://github.com/JuliaStats/Distributions.jl">Distributions.jl</a>. The prior    overrides any parameter bounds.</li><li><code>prior_on_linear_scale = true</code>: Whether the prior is on the linear scale (default) or on   the transformed scale. For example, if <code>scale = :log10</code> and   <code>prior_on_linear_scale = false</code>, the prior acts on the transformed value; <code>log10(x)</code>.</li><li><code>estimate = true</code>: Whether the parameter should be estimated (default) or treated as a   constant.</li><li><code>value = nothing</code>: Value to use if <code>estimate = false</code>, and value retreived by the <code>get_x</code>   function. Defaults to the midpoint between <code>lb</code> and <code>ub</code>.</li></ul><p><strong>Description</strong></p><p>If a prior <span>$\pi(x_i)$</span> is provided, the parameter estimation problem becomes a maximum a posteriori problem instead of a maximum likelihood problem. Practically, instead of minimizing the negative log-likelihood,<span>$-\ell(x)$</span>, the negative posterior is minimized:</p><p class="math-container">\[\min_{\mathbf{x}} -\ell(\mathbf{x}) - \sum_{i} \pi(x_i)\]</p><p>For all parameters <span>$i$</span> with a prior.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/60b721a7804035b6fc9c53163fba622f91aa9261/src/structs/petab_model.jl#L1-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.PEtabEvent" href="#PEtab.PEtabEvent"><code>PEtab.PEtabEvent</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PEtabEvent(condition, affects, targets)</code></pre><p>A model event triggered by <code>condition</code> that sets the value of <code>targets</code> to that of <code>affects</code>.</p><p>For a collection of examples with corresponding plots, see the documentation.</p><p><strong>Arguments</strong></p><ul><li><code>condition</code>: A Boolean expression that triggers the event when it transitions from   <code>false</code> to <code>true</code>. For example, if <code>t == c1</code>, the event is triggered when the model   time <code>t</code> equals <code>c1</code>. For <code>S &gt; 2.0</code>, the event triggers when specie <code>S</code> passes 2.0   from below.</li><li><code>affects</code>: An equation of of model species and parameters that describes the effect of   the event. It can be a single expression or a vector if there are multiple targets.</li><li><code>targets</code>: Model species or parameters that the event acts on. Must match the dimension   of <code>affects</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/60b721a7804035b6fc9c53163fba622f91aa9261/src/structs/petab_model.jl#L125-L142">source</a></section></article><p>Then, given a dynamic model (as <code>ReactionSystem</code> or <code>ODESystem</code>), measurement data as a <code>DataFrame</code>, and potential simulation conditions as a <code>Dict</code> (see <a href="../petab_simcond/#petab_sim_cond">this</a> tutorial), a <code>PEtabModel</code> can be created:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.PEtabModel" href="#PEtab.PEtabModel"><code>PEtab.PEtabModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PEtabModel(sys, observables::Dict{String, PEtabObservable}, measurements::DataFrame,
           parameters::Vector{PEtabParameter}; kwargs...)</code></pre><p>From a <code>ReactionSystem</code> or an <code>ODESystem</code> model, <code>observables</code> that link the model to <code>measurements</code> and <code>parameters</code> to estimate, create a <code>PEtabModel</code> for parameter estimation.</p><p>For examples on how to create a <code>PEtabModel</code>, see the documentation.</p><p>See also <a href="#PEtab.PEtabObservable"><code>PEtabObservable</code></a>, <a href="#PEtab.PEtabParameter"><code>PEtabParameter</code></a>, and <a href="#PEtab.PEtabEvent"><code>PEtabEvent</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>simulation_conditions = nothing</code>: An optional dictionary specifying initial specie values   and/or model parameters for each simulation condition. Only required if the model has   multiple simulation conditions.</li><li><code>events = nothing</code>: Optional model events (callbacks) provided as <code>PEtabEvent</code>. Multiple   events should be provided as a <code>Vector</code> of <code>PEtabEvent</code>.</li><li><code>verbose::Bool = false</code>: Whether to print progress while building the <code>PEtabModel</code>.</li></ul><pre><code class="nohighlight hljs">PEtabModel(path_yaml; kwargs...)</code></pre><p>Import a PEtab problem in the standard format with YAML file at <code>path_yaml</code> into a <code>PEtabModel</code> for parameter estimation.</p><p>For examples on how to import a PEtab problem, see the documentation.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>ifelse_to_callback::Bool = true</code>: Whether to rewrite <code>ifelse</code> (SBML piecewise)   expressions to <a href="https://github.com/SciML/DiffEqCallbacks.jl">callbacks</a>. This improves   simulation runtime. It is strongly recommended to set this to <code>true</code>.</li><li><code>verbose::Bool = false</code>: Whether to print progress while building the <code>PEtabModel</code>.</li><li><code>write_to_file::Bool = false</code>: Whether to write the generated Julia functions to files in  the same directory as the PEtab problem. Useful for debugging.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/60b721a7804035b6fc9c53163fba622f91aa9261/src/structs/petab_model.jl#L149-L184">source</a></section></article><h2 id="PEtabODEProblem"><a class="docs-heading-anchor" href="#PEtabODEProblem">PEtabODEProblem</a><a id="PEtabODEProblem-1"></a><a class="docs-heading-anchor-permalink" href="#PEtabODEProblem" title="Permalink"></a></h2><p>From a <code>PEtabModel</code>, a <code>PEtabODEProblem</code> can:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.PEtabODEProblem" href="#PEtab.PEtabODEProblem"><code>PEtab.PEtabODEProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PEtabODEProblem(model::PEtabModel; kwargs...)</code></pre><p>From <code>model</code> create a <code>PEtabODEProblem</code> for parameter estimation/inference.</p><p>If no options (<code>kwargs</code>) are provided, default settings are used for the <code>ODESolver</code>, gradient method, and Hessian method. For more information on the default options, see the documentation.</p><p>See also <a href="#PEtab.ODESolver"><code>ODESolver</code></a>, <a href="#PEtab.SteadyStateSolver"><code>SteadyStateSolver</code></a>, and <a href="#PEtabModel"><code>PEtabModel</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>odesolver::ODESolver</code>: ODE solver options for computing the likelihood (objective   function).</li><li><code>odesolver_gradient::ODESolver</code>: ODE solver options for computing the gradient. Defaults   to <code>odesolver</code> if not provided.</li><li><code>ss_solver::SteadyStateSolver</code>: Steady-state solver options for computing the likelihood.   Only applicable for models with steady-state simulations.</li><li><code>ss_solver_gradient::SteadyStateSolver</code>: Steady-state solver options for computing the   gradient. Defaults to <code>ss_solver</code> if not provided.</li><li><code>gradient_method::Symbol</code>: Method for computing the gradient. Available options and   defaults are listed in the documentation.</li><li><code>hessian_method::Symbol</code>: Method for computing the Hessian. As with the gradient,   available options and defaults can be found in the documentation.</li><li><code>FIM_method=nothing</code>: Method for computing the empirical Fisher Information Matrix (FIM).   Accepts the same options as <code>hessian_method</code>.</li><li><code>sparse_jacobian=false</code>: Whether to use a sparse Jacobian when solving the ODE model.   This can greatly improve performance for large models.</li><li><code>sensealg</code>: Sensitivity algorithm for gradient computations. Available and default   options depend on <code>gradient_method</code>. See the documentation for details.</li><li><code>chunksize=nothing</code>: Chunk size for ForwardDiff.jl when using forward-mode automatic   differentiation for gradients and Hessians. If not provided, a default value is used.   Tuning <code>chunksize</code> can improve performance but is non-trivial.</li><li><code>split_over_conditions::Bool=false</code>: Whether to split ForwardDiff.jl calls across   simulation conditions when computing the gradient and/or Hessian. This improves   performance for models with many condition-specific parameters, otherwise it increases   runtime.</li><li><code>reuse_sensitivities::Bool=false</code>: Whether to reuse forward sensitivities from the   gradient computation for the Gauss-Newton Hessian approximation. Only applies when   <code>hessian_method=:GaussNewton</code> and <code>gradient_method=:ForwardEquations</code>. This can greatly   improve  performance when the optimization algorithm computes both the gradient and   Hessian simultaneously.</li><li><code>verbose::Bool = false</code>: Whether to print progress while building the <code>PEtabODEProblem</code>.</li></ul><p><strong>Returns</strong></p><p>A <code>PEtabODEProblem</code>, where the key fields are:</p><ul><li><code>nllh</code>: Compute the negative log-likelihood function for an input vector <code>x</code>;   <code>nllh(x)</code>. For this function and the ones below listed below, the input <code>x</code> can be   either a <code>Vector</code> or a <code>ComponentArray</code>.</li><li><code>grad!</code>: Compute the in-place gradient of the nllh; <code>grad!(g, x)</code>.</li><li><code>grad</code>: Compute the out-of-place gradient of the nllh; <code>g = grad(x)</code>.</li><li><code>hess!</code>: Compute the in-place Hessian of the nllh; <code>hess!(H, x)</code>.</li><li><code>hess</code>: Compute the out-of-place Hessian of the nllh; <code>H = hess(x)</code>.</li><li><code>FIM</code>: Compute the out-of-place empirical Fisher Information Matrix (FIM) of the nllh;   <code>F = FIM(x)</code>.</li><li><code>chi2</code>: Compute the chi-squared test statistic for the nllh (see mathematical definition   below); <code>χ² = chi2(x)</code>.</li><li><code>residuals</code>: Computes the residuals between the measurement data and model output (see   the mathematical definition below); <code>r = residuals(x)</code>.</li><li><code>simulated_values</code>: Computes the corresponding model values for each measurement in the   measurements table, in the same order as the measurements appear.</li><li><code>lower_bounds</code>: Lower parameter bounds for parameter estimation, as specified when   creating the <code>model</code>.</li><li><code>upper_bounds</code>: Upper parameter bounds for parameter estimation, as specified when   creating the <code>model</code>.</li></ul><p><strong>Description</strong></p><p>Following the <a href="https://petab.readthedocs.io/en/latest/">PEtab standard</a>, the objective function to be used for parameter estimation created by the <code>PEtabODEProblem</code> is a likelihood function, or, if priors are provided, a posterior function. The characteristics of the objective is defined in the <code>PEtabModel</code>. In practice, for numerical stability, a <code>PEtabODEProblem</code> works with the negative log-likelihood:</p><p class="math-container">\[-\ell(\mathbf{x}) =  - \sum_{i = 1}^N \ell_i(\mathbf{x}),\]</p><p>where <span>$\ell_i$</span> is the likelihood for each measurement <span>$i$</span>. In addition, to accommodate numerical optimization packages, the <code>PEtabODEProblem</code> provides efficient functions for computing the gradient <span>$-\nabla \ell(\mathbf{x})$</span> and the second derivative Hessian matrix <span>$-\nabla^2 \ell(\mathbf{x})$</span>, using the specified or default <code>gradient_method</code> and <code>hessian_method</code>.</p><p>In addition to <span>$-\ell$</span> and its derivatives, the <code>PEtabODEProblem</code> provides functions for diagnostics and model selection. The χ² (chi-squared) value can be used for model selection [1], and it is computed as the sum of the χ² values for each measurement. For a measurement <code>y</code>, an observable <code>h = obs_formula</code>, and a standard deviation <code>σ = noise_formula</code>, the χ² is computed as:</p><p class="math-container">\[\chi^2 = \frac{(y - h)^2}{\sigma^2}\]</p><p>The residuals <span>$r$</span> can be used to assess the measurement error model and are computed as:</p><p class="math-container">\[r = \frac{(y - h)}{\sigma}\]</p><p>Lastly, the empirical Fisher Information Matrix (FIM) can be used for identifiability analysis [2]. It should ideally be computed with an exact Hessian method. The inverse of the FIM provides a lower bound on the covariance matrix. While the FIM can be useful, the profile-likelihood approach generally yields better results for identifiability analysis [2].</p><ol><li>Cedersund et al, The FEBS journal, pp 903-922 (2009).</li><li>Raue et al, Bioinformatics, pp 1923-1929 (2009).</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/60b721a7804035b6fc9c53163fba622f91aa9261/src/structs/petab_odeproblem.jl#L351-L461">source</a></section></article><p>A <code>PEtabODEProblem</code> has numerous configurable options. Two of the most important options are the <code>ODESolver</code> and, for models with steady-state simulations, the <code>SteadyStateSolver</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.ODESolver" href="#PEtab.ODESolver"><code>PEtab.ODESolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ODESolver(solver, kwargs..)</code></pre><p>ODE-solver options (<code>solver</code>, <code>tolerances</code>, etc.) used for solving the ODE model in a <code>PEtabODEProblem</code>.</p><p>Any <code>solver</code> from <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a> and <a href="https://github.com/SciML/Sundials.jl">Sundials.jl</a> is supported. For solver recommendations and default options used when an <code>ODESolver</code> is not provided when creating a <code>PEtabODEProblem</code>, see the documentation.</p><p>More information on the available options and solvers can also be found in the documentation for <a href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/">DifferentialEquations.jl</a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>abstol=1e-8</code>: Absolute tolerance when solving the ODE model. It is not recommended to   increase above 1e-6 for gradients in order to obtain accurate gradients.</li><li><code>reltol=1e-8</code>: Absolute tolerance when solving the ODE model. It is not recommended to   increase above 1e-6 for gradients in order to obtain accurate gradients.</li><li><code>dtmin=nothing</code>: Minimum acceptable step size when solving the ODE model.</li><li><code>maxiters=10000</code>: Maximum number of iterations when solving the ODE model. Increasing   above the default value can cause parameter estimation to take substantial longer time.</li><li><code>verbose::Bool=true</code>: Whether or not warnings are displayed if the solver exits early.   <code>true</code> is recommended to detect if a suboptimal choice of <code>solver</code>.</li><li><code>adj_solver=solver</code>: Solver to use when solving the adjoint ODE. Only applicable if   <code>gradient_method=:Adjoint</code> when creating the <code>PEtabODEProblem</code>. Defaults to <code>solver</code>.</li><li><code>abstol_adj=abstol</code>: Absolute tolerance when solving the adjoint ODE model. Only   applicable if <code>gradient_method=:Adjoint</code> when creating the <code>PEtabODEProblem</code>. Defaults   to <code>abstol</code>.</li><li><code>reltol_adj=abstol</code>: Relative tolerance when solving the adjoint ODE model. Only   applicable if <code>gradient_method=:Adjoint</code> when creating the <code>PEtabODEProblem</code>. Defaults   to <code>reltol</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/60b721a7804035b6fc9c53163fba622f91aa9261/src/structs/petab_odeproblem.jl#L154-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.SteadyStateSolver" href="#PEtab.SteadyStateSolver"><code>PEtab.SteadyStateSolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SteadyStateSolver(method::Symbol; kwargs...)</code></pre><p>Steady-state solver options (<code>method</code>, <code>tolerances</code>, etc.) for computing the steady state, where the ODE right-hand side <code>f</code> fulfills <code>du = f(u, p, t) ≈ 0</code>.</p><p>The steady state can be computed in two ways. If <code>method=:Simulate</code>, by simulating the ODE model until <code>du = f(u, p, t) ≈ 0</code> using ODE solver options defined in the provied <code>ODESolver</code> to the <code>PEtabODEProblem. This approach is **strongly** recommended. If</code>method=:Rootfinding<code>, by directly finding the root of the RHS</code>f(u, p, t) = 0` using any algorithm from NonlinearSolve.jl. The root-finding approach is far less reliable than the simulation approach (see description below).</p><p><strong>Keyword Arguments</strong></p><ul><li><code>termination_check = :wrms</code>: Approach to check if the model has reached steady-state for   <code>method = :Simulate</code>. Two approaches are supported:<ul><li><code>:wrms</code>: Weighted root-mean-square. Terminate when: <span>$\sqrt{\frac{1}{N} \sum_i^N \Big( \frac{du_i}{reltol * u_i + abstol}\Big)^2} &lt; 1$</span></li><li><code>:Newton</code>: Terminate if the step for Newton&#39;s method <code>Δu</code> is sufficiently small: <span>$\sqrt{\frac{1}{N} \sum_i^N \Big(\frac{\Delta u_i}{reltol * u_i + abstol}\Big)^2} &lt; 1$</span> The <code>:Newton</code> approach requires that the Newton step <code>Δu</code> can be computed, which is only possible if the Jacobian of the RHS of the ODE model is invertible. If this is not the case, a pseudo-inverse is used if <code>pseudoinverse = true</code>, else <code>wrms</code> is used. The <code>:Newton</code> termination should perform better than <code>:wrms</code> as it accounts for the scale of the ODEs, but until benchmarks confirm this, we recommend <code>:wrms</code>.</li></ul></li><li><code>pseudoinverse = true</code>: Whether to use a pseudo-inverse if inverting the Jacobian fails   for <code>termination_check = :Newton</code>.</li><li><code>rootfinding_alg = nothing</code>: Root-finding algorithm from NonlinearSolve.jl to use if   <code>method = :Rootfinding</code>. If left empty, the default NonlinearSolve.jl algorithm is used.</li><li><code>abstol</code>: Absolute tolerance for the NonlinearSolve.jl root-finding problem or the   <code>termination_check</code> formula. Defaults to <code>100 * abstol_ode</code>, where <code>abstol_ode</code> is the   tolerance for the <code>ODESolver</code> in the <code>PEtabODEProblem</code>.</li><li><code>reltol</code>: Relative tolerance for the NonlinearSolve.jl root-finding problem or the   <code>termination_check</code> formula. Defaults to <code>100 * reltol_ode</code>, where <code>reltol_ode</code> is the   tolerance for the <code>ODESolver</code> in the <code>PEtabODEProblem</code>.</li><li><code>maxiters</code>: Maximum number of iterations to use if <code>method = :Rootfinding</code>.</li></ul><p><strong>Description</strong></p><p>For an ODE model of the form:</p><p class="math-container">\[\frac{\mathrm{d}u}{\mathrm{d}t} = du = f(u, p, t)\]</p><p>The steady state is defined by:</p><p class="math-container">\[f(u, p, t) = 0.0\]</p><p>The steady state can be computed in two ways: either by simulating the ODE model from a set of initial values <code>u₀</code> until <code>du ≈ 0</code>, or by using a root-finding algorithm such as <a href="https://en.wikipedia.org/wiki/Newton%27s_method">Newton&#39;s method</a> to directly solve <code>f(u, p, t) = 0.0</code>. While the root-finding approach is computationally more efficient (since it does not require solving the entire ODE), it is far less reliable and can converge to the wrong root. For example, in mass-action models with positive initial values, the feasible root should be positive in <code>u</code>. This is generally fulfilled when computing the steady state via simulation (a negative root typically only occurs if the ODE solver fails). However, with root-finding, there is no such guarantee, as any root that satisfies <code>f(u, p, t) = 0.0</code> may be returned. Consistent with this, benchmarks have shown that simulation is the most reliable method [1].</p><p>Another alternative is to solve for the steady state  symbolically. If feasible, this is the most computationally efficient approach [1].</p><ol><li>Fiedler et al, BMC system biology, pp 1-19 (2016)</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/60b721a7804035b6fc9c53163fba622f91aa9261/src/structs/petab_odeproblem.jl#L218-L284">source</a></section></article><p>PEtab.jl provides several functions for interacting with a <code>PEtabODEProblem</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.get_x" href="#PEtab.get_x"><code>PEtab.get_x</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_x(prob::PEtabODEProblem; linear_scale = false)::ComponentArray</code></pre><p>Get the nominal parameter vector with parameters in the correct order expected by <code>prob</code> for parameter estimation/inference. Nominal values can optionally be specified when creating a <code>PEtabParameter</code>, or in the parameters table if the problem is provided in the PEtab standard format.</p><p>For ease of interaction (e.g., changing values), the parameter vector is returned as a <code>ComponentArray</code>.  For how to interact with a <code>ComponentArray</code>, see the documentation and the ComponentArrays.jl <a href="https://github.com/jonniedie/ComponentArrays.jl">documentation</a>.</p><p>See also <a href="#PEtab.PEtabParameter"><code>PEtabParameter</code></a>.</p><p><strong>Keyword argument</strong></p><ul><li><code>linear_scale</code>: Whether to return parameters on the linear scale. By default, parameters are returned on the scale they are estimated, which by default is <code>log10</code> as this often improves parameter estimation performance.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/60b721a7804035b6fc9c53163fba622f91aa9261/src/util.jl#L191-L209">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.remake-Tuple{PEtabODEProblem, Dict}" href="#SciMLBase.remake-Tuple{PEtabODEProblem, Dict}"><code>SciMLBase.remake</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remake(prob::PEtabODEProblem, xchange::Dict)::PEtabODEProblem</code></pre><p>Fix and consequently remove a set of parameters from being estimated without rebuilding <code>prob</code>.</p><p><code>xchange</code> should be provided as a <code>Dict</code> with parameter names and their new values. For example, to fix <code>k1</code> to <code>1.0</code>, provide <code>xchange = Dict(:k1 =&gt; 1.0)</code>. The parameters to be fixed can only be those that were originally set to be estimated.</p><p><code>remake</code> is the most efficient approach for fixing parameters, as it does not re-compile the problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/60b721a7804035b6fc9c53163fba622f91aa9261/src/petab_odeproblem/remake.jl#L1-L13">source</a></section></article><p>And additionally, functions for interacting with the underlying dynamic model (<code>ODEProblem</code>) within a <code>PEtabODEProblem</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.get_u0" href="#PEtab.get_u0"><code>PEtab.get_u0</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_u0(res, prob::PEtabODEProblem; kwargs...)</code></pre><p>Retrieve the <code>ODEProblem</code> initial values for simulating the ODE model in <code>prob</code>. <code>res</code> can be a parameter estimation result (e.g., <code>PEtabMultistartResult</code>) or a <code>Vector</code> with parameters in the order expected by <code>prob</code> (see <a href="#PEtab.get_x"><code>get_x</code></a>).</p><p>For information on keyword arguements see <a href="#PEtab.get_ps"><code>get_ps</code></a>.</p><p>See also <a href="#PEtab.get_odeproblem"><code>get_odeproblem</code></a> and <a href="#PEtab.get_odesol"><code>get_odesol</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/60b721a7804035b6fc9c53163fba622f91aa9261/src/util.jl#L104-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.get_ps" href="#PEtab.get_ps"><code>PEtab.get_ps</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_ps(res, prob::PEtabODEProblem; kwargs...)</code></pre><p>Retrieve the <code>ODEProblem</code> parameter values for simulating the ODE model in <code>prob</code>. <code>res</code> can be a parameter estimation result (e.g., <code>PEtabMultistartResult</code>) or a <code>Vector</code> with parameters in the order expected by <code>prob</code> (see <a href="#PEtab.get_x"><code>get_x</code></a>).</p><p>See also: <a href="#PEtab.get_u0"><code>get_u0</code></a>, <a href="#PEtab.get_odeproblem"><code>get_odeproblem</code></a>, <a href="#PEtab.get_odesol"><code>get_odesol</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>retmap=true</code>: Whether to return the values as a map in the form <code>[k1 =&gt; val1, ...]</code>. Such   a map can be directly used when building an <code>ODEProblem</code>. If <code>false</code>, a <code>Vector</code> is   returned. This keyword is only applicable for <code>get_u0</code> and <code>get_ps</code>.</li><li><code>cid::Symbol</code>: Which simulation condition to return parameters for. If not provided,   defaults to the first simulation condition. For other <code>get</code> functions, the   <code>ODEProblem</code>, <code>u0</code>, or <code>ODESolution</code> for the specified <code>cid</code> is returned.</li><li><code>preeq_id</code>: Which potential pre-equilibration (steady-state) simulation id to use.   If a valid <code>preeq_id</code> is provided, the ODE is first simulated to steady state for   <code>preeq_id</code>. Then the model shifts to <code>cid</code>, and the parameters for <code>cid</code> are returned.   For other <code>get</code> functions, the  <code>ODEProblem</code>, <code>u0</code>, or <code>ODESolution</code> for the   specified <code>cid</code> is returned</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/60b721a7804035b6fc9c53163fba622f91aa9261/src/util.jl#L75-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.get_system" href="#PEtab.get_system"><code>PEtab.get_system</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_system(res, prob::PEtabODEProblem; kwargs...) -&gt; (sys, p, u0, callbacks)</code></pre><p>Retrieve the dynamic model system, parameter map (<code>p</code>), initial species map (<code>u0</code>), and callbacks (<code>CallbackSet</code>) for the model in <code>prob</code>. The argument <code>res</code> can be a parameter estimation result (e.g., <code>PEtabMultistartResult</code>) or a <code>Vector</code> of parameters in the order expected by <code>prob</code> (see <a href="#PEtab.get_x"><code>get_x</code></a>).</p><p>The system type returned depends on the input to <code>PEtabModel</code>. If the model is provided as a <code>ReactionSystem</code>, a <code>ReactionSystem</code> is returned. The same applies for an <code>ODESystem</code>. If the model is provided via an SBML file, a <code>ReactionSystem</code> is returned.</p><p>For information on keyword arguments, see <a href="#PEtab.get_ps"><code>get_ps</code></a>.</p><p>See also: <a href="#PEtab.get_u0"><code>get_u0</code></a> and <a href="#PEtab.get_odesol"><code>get_odesol</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/60b721a7804035b6fc9c53163fba622f91aa9261/src/util.jl#L45-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.get_odeproblem" href="#PEtab.get_odeproblem"><code>PEtab.get_odeproblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_odeproblem(res, prob::PEtabODEProblem; kwargs...) -&gt; (sys, callbacks)</code></pre><p>Retrieve the <code>ODEProblem</code> and callbacks (<code>CallbackSet</code>) for simulating the ODE model in <code>prob</code>. <code>res</code> can be a parameter estimation result (e.g., <code>PEtabMultistartResult</code>) or a <code>Vector</code> with parameters in the order expected by <code>prob</code> (see <a href="#PEtab.get_x"><code>get_x</code></a>).</p><p>For information on keyword arguements see <a href="#PEtab.get_ps"><code>get_ps</code></a>.</p><p>See also: <a href="#PEtab.get_u0"><code>get_u0</code></a> and <a href="#PEtab.get_odesol"><code>get_odesol</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/60b721a7804035b6fc9c53163fba622f91aa9261/src/util.jl#L23-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.get_odesol" href="#PEtab.get_odesol"><code>PEtab.get_odesol</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_odesol(res, prob::PEtabODEProblem; kwargs...)::ODESolution</code></pre><p>Retrieve the <code>ODESolution</code> from simulating the ODE model in <code>prob</code>. <code>res</code> can be a parameter estimation result (e.g., <code>PEtabMultistartResult</code>) or a <code>Vector</code> with parameters in the order expected by <code>prob</code> (see <a href="#PEtab.get_x"><code>get_x</code></a>).</p><p>For information on keyword arguements see <a href="#PEtab.get_ps"><code>get_ps</code></a>.</p><p>See also: <a href="#PEtab.get_u0"><code>get_u0</code></a> and <a href="#PEtab.get_odeproblem"><code>get_odeproblem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/60b721a7804035b6fc9c53163fba622f91aa9261/src/util.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.solve_all_conditions" href="#PEtab.solve_all_conditions"><code>PEtab.solve_all_conditions</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve_all_conditions(x, prob::PEtabODEProblem, solver; kwargs)</code></pre><p>Solve the ODE model in <code>prob</code> for all simulation conditions with the provided ODE-solver.</p><p><code>x</code> should be a <code>Vector</code> or <code>ComponentArray</code> with parameters in the order expected by <code>prob</code> (see <a href="#PEtab.get_x"><code>get_x</code></a>).</p><p><strong>Keyword Arguments</strong></p><ul><li><code>abstol=1e-8</code>: Absolute tolerance for the ODE solver.</li><li><code>reltol=1e-8</code>: Relative tolerance for the ODE solver.</li><li><code>maxiters=1e4</code>: Maximum iterations for the ODE solver.</li><li><code>ntimepoints_save=0</code>: The number of time points at which to save the ODE solution for   each condition. A value of 0 means the solution is saved at the solvers default time   points.</li><li><code>save_observed_t=false</code>: When set to true, this option overrides <code>ntimepoints_save</code>   and saves the ODE solution only at the time points where measurement data is available.</li></ul><p><strong>Returns</strong></p><ul><li><code>odesols</code>: A dictionary containing the <code>ODESolution</code> for each simulation condition.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/60b721a7804035b6fc9c53163fba622f91aa9261/src/util.jl#L214-L234">source</a></section></article><h2 id="Parameter-Estimation"><a class="docs-heading-anchor" href="#Parameter-Estimation">Parameter Estimation</a><a id="Parameter-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-Estimation" title="Permalink"></a></h2><p>A <code>PEtabODEProblem</code> contains all the necessary information for wrapping a suitable numerical optimization library, but for convenience, PEtab.jl provides wrappers for several available optimizers. In particular, single-start parameter estimation is provided via <code>calibrate</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.calibrate" href="#PEtab.calibrate"><code>PEtab.calibrate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calibrate(prob::PEtabODEProblem, x0, alg; kwargs...)::PEtabOptimisationResult</code></pre><p>From starting point <code>x0</code> using optimization algorithm <code>alg</code>, estimate unknown model parameters for <code>prob</code>, and get results as a <code>PEtabOptimisationResult</code>.</p><p><code>x0</code> can be a <code>Vector</code> or a <code>ComponentArray</code>, where the individual parameters must be in the order expected by <code>prob</code>. To get a vector in the correct order, see <a href="#PEtab.get_x"><code>get_x</code></a>.</p><p>A list of available and recommended optimization algorithms (<code>alg</code>) can be found in the documentation. Briefly, supported algorithms are from:</p><ul><li><a href="https://julianlsolvers.github.io/Optim.jl/stable/">Optim.jl</a>: <code>LBFGS()</code>, <code>BFGS()</code>,   or <code>IPNewton()</code> methods.</li><li><a href="https://coin-or.github.io/Ipopt/">Ipopt.jl</a>: <code>IpoptOptimizer()</code> interior-point Newton   method.</li><li><a href="https://github.com/fides-dev/fides">Fides.py</a>: <code>Fides()</code> Newton trust region method.</li></ul><p>Different ways to visualize the parameter estimation result can be found in the documentation.</p><p>See also <a href="#PEtab.PEtabOptimisationResult"><code>PEtabOptimisationResult</code></a>, <a href="../pest_algs/#Fides"><code>Fides</code></a> and <a href="#PEtab.IpoptOptimizer"><code>IpoptOptimizer</code></a></p><p><strong>Keyword Arguments</strong></p><ul><li><code>save_trace::Bool = false</code>: Whether to save the optimization trace of the objective   function and parameter vector. Only applicable for some algorithms; see the   documentation for details.</li><li><code>options = DEFAULT_OPTIONS</code>: Configurable options for <code>alg</code>. The type and available   options depend on which package <code>alg</code> belongs to. For example, if <code>alg = IPNewton()</code>   from Optim.jl, <code>options</code> should be provided as an <code>Optim.Options()</code> struct. A list of   configurable options can be found in the documentation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/60b721a7804035b6fc9c53163fba622f91aa9261/src/parameter_estimation/singlestart.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.PEtabOptimisationResult" href="#PEtab.PEtabOptimisationResult"><code>PEtab.PEtabOptimisationResult</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PEtabOptimisationResult</code></pre><p>Parameter estimation statistics from single-start optimization with <code>calibrate</code>.</p><p>See also: <a href="#PEtab.calibrate"><code>calibrate</code></a></p><p><strong>Fields</strong></p><ul><li><code>xmin</code>: Minimizing parameter vector found by the optimization.</li><li><code>fmin</code>: Minimum objective value found by the optimization.</li><li><code>x0</code>: Starting parameter vector.</li><li><code>alg</code>: Parameter estimation algorithm used.</li><li><code>niterations</code>: Number of iterations for the optimization.</li><li><code>runtime</code>: Runtime in seconds for the optimization.</li><li><code>xtrace</code>: Parameter vector optimization trace. Empty if <code>save_trace = false</code> was   provided to <code>calibrate</code>.</li><li><code>ftrace</code>: Objective function optimization trace. Empty if <code>save_trace = false</code> was   provided to <code>calibrate</code>.</li><li><code>converged</code>: Convergence flag from <code>alg</code>.</li><li><code>original</code>: Original result struct returned by <code>alg</code>. For example, if <code>alg = IPNewton()</code>   from Optim.jl, <code>original</code> is the Optim return struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/60b721a7804035b6fc9c53163fba622f91aa9261/src/structs/parameter_estimation.jl#L108-L129">source</a></section></article><p>Multi-start (recommended method) parameter estimation, is provided via <code>calibrate_multistart</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.calibrate_multistart" href="#PEtab.calibrate_multistart"><code>PEtab.calibrate_multistart</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calibrate_multistart(prob::PEtabODEProblem, alg, nmultistarts::Integer; nprocs = 1,
                     dirsave=nothing, kwargs...)::PEtabMultistartResult</code></pre><p>Perform <code>nmultistarts</code> parameter estimation runs from randomly sampled starting points using the optimization algorithm <code>alg</code> to estimate the unknown model parameters in <code>prob</code>.</p><p>A list of available and recommended optimisation algorithms (<code>alg</code>) can be found in the package documentation and in the <a href="#PEtab.calibrate"><code>calibrate</code></a> documentation.</p><p>If <code>nprocs &gt; 1</code>, the parameter estimation runs are performed in parallel using the <a href="https://docs.julialang.org/en/v1/stdlib/Distributed/#Distributed.pmap"><code>pmap</code></a> function from Distributed.jl with <code>nprocs</code> processes. If parameter estimation on a single process (<code>nprocs = 1</code>) takes longer than 5 minutes, we <strong>strongly</strong> recommend setting <code>nprocs &gt; 1</code>, as this can greatly reduce runtime. Note that <code>nprocs</code> should not be larger than the number of cores on the computer.</p><p>If <code>dirsave</code> is provided, intermediate results for each run are saved in <code>dirsave</code>. It is <strong>strongly</strong> recommended to provide <code>dirsave</code> for larger models, as parameter estimation can take hours (or even days!),and without <code>dirsave</code>, all intermediate results will be lost if something goes wrong.</p><p>Different ways to visualize the parameter estimation result can be found in the documentation.</p><p>See also <a href="#PEtab.PEtabMultistartResult"><code>PEtabMultistartResult</code></a>, <a href="#PEtab.get_startguesses"><code>get_startguesses</code></a>, and <a href="#PEtab.calibrate"><code>calibrate</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>sampling_method = LatinHypercubeSample()</code>: Method for sampling a diverse (spread out) set  of starting points. See the documentation for <a href="#PEtab.get_startguesses"><code>get_startguesses</code></a>, which is the  function used for sampling.</li><li><code>sample_prior::Bool = true</code>: See the documentation for <a href="#PEtab.get_startguesses"><code>get_startguesses</code></a>.</li><li><code>seed = nothing</code>: Seed used when generating starting points.</li><li><code>options = DEFAULT_OPTIONS</code>: Configurable options for <code>alg</code>. See the documentation for   <a href="#PEtab.calibrate"><code>calibrate</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/60b721a7804035b6fc9c53163fba622f91aa9261/src/parameter_estimation/multistart.jl#L1-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.get_startguesses" href="#PEtab.get_startguesses"><code>PEtab.get_startguesses</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_startguesses(prob::PEtabODEProblem, n::Integer; kwargs...)</code></pre><p>Generate <code>n</code> random parameter vectors within the parameter bounds in <code>prob</code>.</p><p>If <code>n = 1</code>, a single random vector is returned. For <code>n &gt; 1</code>, a vector of random parameter vectors is returned. In both cases, parameter vectors are returned as a <code>ComponentArray</code>. For details on how to interact with a <code>ComponentArray</code>, see the documentation and the ComponentArrays.jl <a href="https://github.com/jonniedie/ComponentArrays.jl">documentation</a>.</p><p>See also <a href="#PEtab.calibrate"><code>calibrate</code></a> and <a href="#PEtab.calibrate_multistart"><code>calibrate_multistart</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>sampling_method = LatinHypercubeSample()</code>: Method for sampling a diverse (spread out) set  of parameter vectors. Any algorithm from  <a href="https://github.com/SciML/QuasiMonteCarlo.jl">QuasiMonteCarlo</a> is allowed, but the  default <code>LatinHypercubeSample</code> is recommended as it usually performs well.</li><li><code>sample_prior::Bool = true</code>: Whether to sample random parameter values from the  prior distribution if a parameter has a prior.</li><li><code>allow_inf::Bool = false</code>: Whether to return parameter vectors for which the likelihood  cannot be computed (typically happens because the <code>ODEProblem</code> cannot be solved). Often  it only makes sense to use starting points with a computable likelihood for  parameter estimation, hence it typically does not make sense to change this option.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/60b721a7804035b6fc9c53163fba622f91aa9261/src/parameter_estimation/startguesses.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.PEtabMultistartResult" href="#PEtab.PEtabMultistartResult"><code>PEtab.PEtabMultistartResult</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PEtabMultistartResult</code></pre><p>Parameter estimation statistics from multi-start optimization with <code>calibrate_multistart</code>.</p><p>See also <a href="#PEtab.calibrate_multistart"><code>calibrate_multistart</code></a> and <a href="#PEtab.PEtabOptimisationResult"><code>PEtabOptimisationResult</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>xmin</code>: Best minimizer across all runs.</li><li><code>fmin</code>: Best minimum across all runs.</li><li><code>alg</code>: Parameter estimation algorithm.</li><li><code>nmultistarts</code>: Number of parameter estimation runs.</li><li><code>sampling_method</code>: Sampling method used for generating starting points.</li><li><code>dirsave</code>: Path of directory where parameter estimation run statistics are saved if   <code>dirsave</code> was provided to <code>calibrate_multistart</code>.</li><li><code>runs</code>: Vector of <code>PEtabOptimisationResult</code> with the parameter estimation results   for each run.</li></ul><pre><code class="nohighlight hljs">PEtabMultistartResult(dirres::String; which_run::String=&quot;1&quot;)</code></pre><p>Import multistart parameter estimation results saved at <code>dirres</code>.</p><p>Each time a new optimization run is performed, results are saved with unique numerical endings. Results from a specific run can be retrieved by specifying the numerical ending with <code>which_run</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/60b721a7804035b6fc9c53163fba622f91aa9261/src/structs/parameter_estimation.jl#L143-L169">source</a></section></article><p>Lastly, model selection is provided via <code>petab_select</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.petab_select" href="#PEtab.petab_select"><code>PEtab.petab_select</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">petab_select(path_yaml, alg; nmultistarts = 100, kwargs...) -&gt; path_res</code></pre><p>For a PEtab-select problem, perform model selection with the method specified in the PEtab select problem files. Returns the path (<code>path_res</code>) to a YAML-file with model selection results.</p><p>The general model selection (e.g. to use forward-search) options are specified in the PEtab-select files. For details on how to set this up, see the PEtab-select <a href="https://github.com/PEtab-dev/petab_select">documentation</a>.</p><p>For each round of model selection, the candidate models are parameter estimated using multi-start parameter estimation, with <code>nmultistarts</code> performed for each model. The objective values obtained from parameter estimation are then used for the next round of  model evaluation.</p><p>A list of available and recommended optimization algorithms (<code>alg</code>) can be found in the package documentation and <a href="#PEtab.calibrate"><code>calibrate</code></a> documentation.</p><p>See also <a href="#PEtab.calibrate_multistart"><code>calibrate_multistart</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>kwargs</code>: The same keywords accepted by <a href="#PEtabODEProblem"><code>PEtabODEProblem</code></a> and <a href="#PEtab.calibrate"><code>calibrate</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/60b721a7804035b6fc9c53163fba622f91aa9261/src/parameter_estimation/petab_select.jl#L1-L24">source</a></section></article><p>For each case case, PEtab.jl supports the usage of optimization algorithms from <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a>, <a href="https://github.com/jump-dev/Ipopt.jl">Ipopt.jl</a>, and <a href="https://github.com/fides-dev/fides">Fides.py</a>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.Fides" href="#PEtab.Fides"><code>PEtab.Fides</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Fides(hessian_method; verbose::Bool=false)</code></pre><p>Setup the <a href="https://github.com/fides-dev/fides">Fides</a> box-constrained Newton-trust region optimizer for parameter estimation.</p><p>See also <a href="#PEtab.calibrate"><code>calibrate</code></a> and <a href="#PEtab.calibrate_multistart"><code>calibrate_multistart</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>hessian_method</code>: Method for computing the Hessian. Allowed options are:<ul><li><code>nothing</code>: The Hessian computed by the <code>PEtabODEProblem</code> is used.</li><li><code>:BB</code>: Broyden&#39;s &quot;bad&quot; method.</li><li><code>:BFGS</code>: Broyden-Fletcher-Goldfarb-Shanno update strategy.</li><li><code>:BG</code>: Broyden&#39;s &quot;good&quot; method.</li><li><code>:Broyden</code>: Broyden-class update scheme.</li><li><code>:SR1</code>: Symmetric Rank 1 update.</li><li><code>:SSM</code>: Structured Secant Method.</li><li><code>:TSSM</code>: Totally Structured Secant Method.</li></ul></li><li><code>verbose</code>: Whether to print progress during the parameter estimation.</li></ul><p><strong>Description</strong></p><p>Fides is a Newton-trust region optimizer for box-constrained optmization problems. More information on the algorithm can be found in [1]. Fides particularly excels when the full Hessian is too computationally expensive to compute, but a Gauss-Newton Hessian approximation can be computed (for more details see the documentation). In addition to supporting user Hessians via the <code>PEtabODEProblem</code>, it supports several Hessian approximation methods. Aa more extensive description than above see the Fides <a href="https://github.com/fides-dev/fides">documentation</a>.</p><ol><li>Fröhlich and Sorger, PLoS computational biology, pp e1010322 (2022)</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/60b721a7804035b6fc9c53163fba622f91aa9261/src/structs/parameter_estimation.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.IpoptOptimizer" href="#PEtab.IpoptOptimizer"><code>PEtab.IpoptOptimizer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IpoptOptimizer(LBFGS::Bool)</code></pre><p>Setup the <a href="https://coin-or.github.io/Ipopt/">Ipopt</a> Interior-point Newton method optmizer for parameter estimation.</p><p>Ipopt can be configured to use either the Hessian method from the <code>PEtabODEProblem</code> (<code>LBFGS=false</code>) or an LBFGS scheme (<code>LBFGS=true</code>). For setting other Ipopt options, see <a href="#PEtab.IpoptOptions"><code>IpoptOptions</code></a>.</p><p>See also <a href="#PEtab.calibrate"><code>calibrate</code></a> and <a href="#PEtab.calibrate_multistart"><code>calibrate_multistart</code></a>.</p><p><strong>Description</strong></p><p>Ipopt is an Interior-point Newton method for constrained non-linear optimization problems. More information on the algorithm can be found in [1].</p><ol><li>Wächter and Biegler, Mathematical programming, pp 25-57 (2006)</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/60b721a7804035b6fc9c53163fba622f91aa9261/src/structs/parameter_estimation.jl#L49-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.IpoptOptions" href="#PEtab.IpoptOptions"><code>PEtab.IpoptOptions</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IpoptOptions(; kwargs...)</code></pre><p>Options for parameter estimation with <code>IpoptOptimizer</code>.</p><p>More details on the options can be found in the Ipopt <a href="https://coin-or.github.io/Ipopt/">documentation</a>.</p><p>See also <a href="#PEtab.IpoptOptimizer"><code>IpoptOptimizer</code></a>, <a href="#PEtab.calibrate"><code>calibrate</code></a>, and <a href="#PEtab.calibrate_multistart"><code>calibrate_multistart</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>print_level = 0</code>: Output verbosity level (valid values are 0 ≤ print_level ≤ 12)</li><li><code>max_iter = 1000</code>: Maximum number of iterations</li><li><code>tol = 1e-8</code>: Relative convergence tolerance</li><li><code>acceptable_tol = 1e-6</code>: Acceptable relative convergence tolerance</li><li><code>max_wall_time 1e20</code>: Maximum wall time optimization is allowed to run</li><li><code>acceptable_obj_change_tol 1e20</code>: Acceptance stopping criterion based on objective   function change.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/60b721a7804035b6fc9c53163fba622f91aa9261/src/structs/parameter_estimation.jl#L72-L92">source</a></section></article><p>Parameter estimation results can be visualized using the plot-recipes detailed in <a href="../pest_plot/#optimization_output_plotting">this</a> page, and with <code>get_obs_comparison_plots</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.get_obs_comparison_plots" href="#PEtab.get_obs_comparison_plots"><code>PEtab.get_obs_comparison_plots</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_obs_comparison_plots(res, prob::PEtabODEProblem; kwargs...)::Dict</code></pre><p>Plot the model fit against data for all simulation conditions and all observable ids for a PEtab.jl parameter estimation result (<code>res</code>).</p><p>Each entry in the returned <code>Dict</code> corresponds to <code>plot(res, prob; obsids=[obsid], cid=cid, kwargs...)</code> for all possible <code>cid</code> and all <code>obsid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/60b721a7804035b6fc9c53163fba622f91aa9261/src/parameter_estimation/plot.jl#L1-L10">source</a></section></article><p>As an alternative to the PEtab.jl interface to parameter estimation, a <code>PEtabODEProblem</code> can be converted to an <code>OptimizationProblem</code> to access the algorithms available via <a href="https://github.com/SciML/Optimization.jl">Optimization.jl</a>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.OptimizationProblem" href="#PEtab.OptimizationProblem"><code>PEtab.OptimizationProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OptimizationProblem(prob::PEtabODEProblem; box_constraints::Bool = true)</code></pre><p>Create an <a href="https://github.com/SciML/Optimization.jl">Optimization.jl</a> <code>OptimizationProblem</code> from <code>prob</code>.</p><p>To use algorithms not compatible with box constraints (e.g., Optim.jl <code>NewtonTrustRegion</code>), set <code>box_constraints = false</code>. Note that with this option, optimizers may move outside the bounds, which can negatively impact performance. More information on how to use an <code>OptimizationProblem</code> can be found in the Optimization.jl <a href="https://docs.sciml.ai/Optimization/stable/">documentation</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/60b721a7804035b6fc9c53163fba622f91aa9261/src/parameter_estimation/singlestart.jl#L34-L45">source</a></section></article><h2 id="Bayesian-Inference"><a class="docs-heading-anchor" href="#Bayesian-Inference">Bayesian Inference</a><a id="Bayesian-Inference-1"></a><a class="docs-heading-anchor-permalink" href="#Bayesian-Inference" title="Permalink"></a></h2><p>PEtab.jl offers wrappers to perform Bayesian inference using state-of-the-art methods such as <a href="https://github.com/TuringLang/Turing.jl">NUTS</a> (the same sampler used in <a href="https://github.com/TuringLang/Turing.jl">Turing.jl</a>) or <a href="https://github.com/mvihola/AdaptiveMCMC.jl">AdaptiveMCMC.jl</a>. It should be noted that this part of PEtab.jl is planned to be moved to a separate package, so the syntax will change and be made more user-friendly in the future.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.PEtabLogDensity" href="#PEtab.PEtabLogDensity"><code>PEtab.PEtabLogDensity</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>PEtabLogDensity(prob::PEtabODEProblem)</p><p>Create a <code>LogDensityProblem</code> using the posterior and gradient functions from <code>prob</code>.</p><p>This <a href="https://github.com/tpapp/LogDensityProblems.jl"><code>LogDensityProblem</code> interface</a> defines everything needed to perform Bayesian inference with packages such as <code>AdvancedHMC.jl</code> (which includes algorithms like NUTS, used by <code>Turing.jl</code>), and <code>AdaptiveMCMC.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/60b721a7804035b6fc9c53163fba622f91aa9261/src/structs/inference.jl#L14-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.to_prior_scale" href="#PEtab.to_prior_scale"><code>PEtab.to_prior_scale</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">to_prior_scale(xpetab, target::PEtabLogDensity)</code></pre><p>Transforms parameter <code>x</code> from the PEtab problem scale to the prior scale.</p><p>This conversion is needed for Bayesian inference, as in PEtab.jl Bayesian inference is performed on the prior scale.</p><div class="admonition is-info" id="Note-565b3f702fe05459"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-565b3f702fe05459" title="Permalink"></a></header><div class="admonition-body"><p>To use this function, the Bijectors, LogDensityProblems, and LogDensityProblemsAD packages must be loaded: <code>using Bijectors, LogDensityProblems, LogDensityProblemsAD</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/60b721a7804035b6fc9c53163fba622f91aa9261/src/PEtab.jl#L118-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.to_chains" href="#PEtab.to_chains"><code>PEtab.to_chains</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">to_chains(res, target::PEtabLogDensity; kwargs...)::MCMCChains</code></pre><p>Converts Bayesian inference results obtained with <code>PEtabLogDensity</code> into an <code>MCMCChains</code>.</p><p><code>res</code> can be the inference results from AdvancedHMC.jl or AdaptiveMCMC.jl. The returned chain has the parameters on the prior scale.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>start_time</code>: Optional starting time for the inference, obtained with <code>now()</code>.</li><li><code>end_time</code>: Optional ending time for the inference, obtained with <code>now()</code>.</li></ul><div class="admonition is-info" id="Note-79b4253d8e75e248"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-79b4253d8e75e248" title="Permalink"></a></header><div class="admonition-body"><p>To use this function, the MCMCChains package must be loaded: <code>using MCMCChains</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/60b721a7804035b6fc9c53163fba622f91aa9261/src/PEtab.jl#L132-L146">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../inference/">« Bayesian Inference</a><a class="docs-footer-nextpage" href="../grad_hess_methods/">Gradient and Hessian Methods »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Tuesday 24 June 2025 18:55">Tuesday 24 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
