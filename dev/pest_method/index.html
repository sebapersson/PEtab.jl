<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parameter Estimation Methods · PEtab.jl</title><meta name="title" content="Parameter Estimation Methods · PEtab.jl"/><meta property="og:title" content="Parameter Estimation Methods · PEtab.jl"/><meta property="twitter:title" content="Parameter Estimation Methods · PEtab.jl"/><meta name="description" content="Documentation for PEtab.jl."/><meta property="og:description" content="Documentation for PEtab.jl."/><meta property="twitter:description" content="Documentation for PEtab.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom_theme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PEtab.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Extended Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../petab_simcond/">Simulation conditions</a></li><li><a class="tocitem" href="../petab_preeq_simulations/">Steady-State Simulations (Pre-Equilibration)</a></li><li><a class="tocitem" href="../petab_event/">Events (callbacks, dosages, etc.)</a></li><li><a class="tocitem" href="../petab_cond_specific/">Simulation Condition-Specific Parameters</a></li><li><a class="tocitem" href="../petab_obs_noise/">Noise and Observable Parameters</a></li><li><a class="tocitem" href="../import_petab/">Importing PEtab Standard Format</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Parameter Estimation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Parameter Estimation Methods</a><ul class="internal"><li><a class="tocitem" href="#Single-Start-Parameter-Estimation"><span>Single-Start Parameter Estimation</span></a></li><li><a class="tocitem" href="#multistart_est"><span>Multi-Start Parameter Estimation</span></a></li><li><a class="tocitem" href="#Creating-an-OptimizationProblem"><span>Creating an OptimizationProblem</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../pest_plot/">Plotting Estimation Results</a></li><li><a class="tocitem" href="../pest_algs/">Available and Recommended Algorithms</a></li><li><a class="tocitem" href="../pest_select/">Model Selection with PEtab-select</a></li><li><a class="tocitem" href="../pest_custom/">Wrapping Optimization Packages</a></li></ul></li><li><a class="tocitem" href="../inference/">Bayesian Inference</a></li><li><a class="tocitem" href="../API/">API</a></li><li><a class="tocitem" href="../grad_hess_methods/">Gradient and Hessian Methods</a></li><li><a class="tocitem" href="../default_options/">Default Options</a></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Performance Tips</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../nonstiff_models/">Non-Biology (Non-Stiff) Models</a></li><li><a class="tocitem" href="../Beer/">Condition-Specific Parameters</a></li><li><a class="tocitem" href="../Bachmann/">Adjoint Sensitivity Analysis (Large Models)</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li><li><a class="tocitem" href="../FAQ/">FAQ</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Parameter Estimation</a></li><li class="is-active"><a href>Parameter Estimation Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Parameter Estimation Methods</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/sebapersson/PEtab.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/sebapersson/PEtab.jl/blob/main/docs/src/pest_method.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="pest_methods"><a class="docs-heading-anchor" href="#pest_methods">Parameter Estimation Methods</a><a id="pest_methods-1"></a><a class="docs-heading-anchor-permalink" href="#pest_methods" title="Permalink"></a></h1><p>The main function of PEtab.jl is to create parameter estimation problems and provide runtime-efficient gradient and Hessian functions for estimating unknown model parameters using suitable numerical optimization algorithms. Specifically, the parameter estimation problems considered by PEtab.jl are on the form:</p><p class="math-container">\[\min_{\mathbf{x} \in \mathbb{R}^N} -\ell(\mathbf{x}), \quad \text{subject to} \\
\mathbf{lb} \leq \mathbf{x} \leq \mathbf{ub}\]</p><p>Where, since PEtab.jl works with likelihoods (see the <a href="../API/#API">API</a> documentation on <code>PEtabObservable</code>), <span>$-\ell(\mathbf{x})$</span> is a negative log-likelihood, and <span>$\mathbf{lb}$</span> and <span>$\mathbf{ub}$</span> are the lower and upper parameter bounds. For a good introduction to parameter estimation for ODE models in biology (which is applicable to other fields as well), see [<a href="../references/#villaverde2022protocol">9</a>].</p><p>This advanced section of the documentation focuses on PEtab.jl&#39;s parameter estimation functionality, and before reading this part, we recommended the starting <a href="../tutorial/#tutorial">tutorial</a>. Specifically, this section of the documentation covers available and recommended optimization algorithms, how to plot optimization results, and how to perform automatic model selection. First though, it covers how to perform parameter estimation. While the <code>PEtabODEProblem</code> contains all the necessary information for wrapping a suitable optimizer to solve the problem (see <a href="../pest_custom/#wrap_est">here</a>), manually wrapping optimizers is cumbersome. Therefore, PEtab.jl provides convenient wrappers for:</p><ul><li>Single-start parameter estimation</li><li>Multi-start parameter estimation</li><li>Creating an <code>OptimizationProblem</code> to access the solvers in <a href="https://github.com/SciML/Optimization.jl">Optimization.jl</a></li></ul><p>As a working example, we use the Michaelis-Menten enzyme kinetics model from the starting <a href="../tutorial/#tutorial">tutorial</a>. Even though the code below presents the model as a <code>ReactionSystem</code>, everything works the same if the model is provided as an <code>ODESystem</code>.</p><pre><code class="language-julia hljs">using Catalyst, PEtab

# Create the dynamic model
rn = @reaction_network begin
    @parameters S0 c3=1.0
    @species S(t)=S0
    c1, S + E --&gt; SE
    c2, SE --&gt; S + E
    c3, SE --&gt; P + E
end
speciemap = [:E =&gt; 50.0, :SE =&gt; 0.0, :P =&gt; 0.0]

# Observables
@unpack E, S = rn
obs_sum = PEtabObservable(S + E, 3.0)
@unpack P = rn
@parameters sigma
obs_p = PEtabObservable(P, sigma)
observables = Dict(&quot;obs_p&quot; =&gt; obs_p, &quot;obs_sum&quot; =&gt; obs_sum)

# Parameters to estimate
p_c1 = PEtabParameter(:c1)
p_c2 = PEtabParameter(:c2)
p_s0 = PEtabParameter(:S0)
p_sigma = PEtabParameter(:sigma)
pest = [p_c1, p_c2, p_s0, p_sigma]

# Simulate measurement data with &#39;true&#39; parameters
using OrdinaryDiffEq, DataFrames
ps = [:c1 =&gt; 1.0, :c2 =&gt; 10.0, :c3 =&gt; 1.0, :S0 =&gt; 100.0]
u0 = [:S =&gt; 100.0, :E =&gt; 50.0, :SE =&gt; 0.0, :P =&gt; 0.0]
tspan = (0.0, 10.0)
oprob = ODEProblem(rn, u0, tspan, ps)
sol = solve(oprob, Rodas5P(); saveat = 0:0.5:10.0)
obs_sum = (sol[:S] + sol[:E]) .+ randn(length(sol[:E]))
obs_p = sol[:P] + .+ randn(length(sol[:P]))
df_sum = DataFrame(obs_id = &quot;obs_sum&quot;, time = sol.t, measurement = obs_sum)
df_p = DataFrame(obs_id = &quot;obs_p&quot;, time = sol.t, measurement = obs_p)
measurements = vcat(df_sum, df_p)

model = PEtabModel(rn, observables, measurements, pest; speciemap = speciemap)
petab_prob = PEtabODEProblem(model)</code></pre><h2 id="Single-Start-Parameter-Estimation"><a class="docs-heading-anchor" href="#Single-Start-Parameter-Estimation">Single-Start Parameter Estimation</a><a id="Single-Start-Parameter-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Single-Start-Parameter-Estimation" title="Permalink"></a></h2><p>Single-start parameter estimation is an approach where a numerical optimization algorithm is run from a starting point <code>x0</code> until it hopefully reaches a local minimum. When performing parameter estimation, the objective function generated by a <code>PEtabODEProblem</code> expects the parameters to be in a specific order. The most straightforward way to obtain a correctly ordered vector is via the <code>get_x</code> function:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.get_x-pest_method" href="#PEtab.get_x-pest_method"><code>PEtab.get_x</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_x(prob::PEtabODEProblem; linear_scale = false)::ComponentArray</code></pre><p>Get the nominal parameter vector with parameters in the correct order expected by <code>prob</code> for parameter estimation/inference. Nominal values can optionally be specified when creating a <code>PEtabParameter</code>, or in the parameters table if the problem is provided in the PEtab standard format.</p><p>For ease of interaction (e.g., changing values), the parameter vector is returned as a <code>ComponentArray</code>.  For how to interact with a <code>ComponentArray</code>, see the documentation and the ComponentArrays.jl <a href="https://github.com/jonniedie/ComponentArrays.jl">documentation</a>.</p><p>See also <a href="../API/#PEtab.PEtabParameter"><code>PEtabParameter</code></a>.</p><p><strong>Keyword argument</strong></p><ul><li><code>linear_scale</code>: Whether to return parameters on the linear scale. By default, parameters are returned on the scale they are estimated, which by default is <code>log10</code> as this often improves parameter estimation performance.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/aed29b2cc8f19f6309de7bf8126eea0b3e51589c/src/util.jl#L192-L210">source</a></section></article><p>For our working example, we have:</p><pre><code class="language-julia hljs">x0 = get_x(petab_prob)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ComponentVector{Float64}(log10_c1 = 2.6989704386302837, log10_c2 = 2.6989704386302837, log10_S0 = 2.6989704386302837, log10_sigma = 2.6989704386302837)</code></pre><p>As discussed in the starting tutorial, <code>x0</code> is a <code>ComponentArray</code>, meaning it holds both parameter values and names. Additionally, parameters like <code>c1</code> have a <code>log10</code> prefix, as the parameter (by default) is estimated on the <code>log10</code> scale, which typically improves performance [<a href="../references/#raue2013lessons">2</a>, <a href="../references/#hass2019benchmark">3</a>]. Interacting with a <code>ComponentArray</code> is straightforward, for example, to change <code>c1</code> to <code>10.0</code> do:</p><pre><code class="language-julia hljs">x0.log10_c1 = log10(10.0)</code></pre><p>or alteratively:</p><pre><code class="language-julia hljs">x0[:log10_c1] = log10(10.0)</code></pre><div class="admonition is-info" id="Note-7d344c027365772c"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-7d344c027365772c" title="Permalink"></a></header><div class="admonition-body"><p>When setting values in the starting point vector <code>x0</code>, the new value should be provided on the parameter&#39;s scale, which is <code>log10</code> by default.</p></div></div><p>Given a starting point, parameter estimation can be performed with the <code>calibrate</code> function:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.calibrate-pest_method" href="#PEtab.calibrate-pest_method"><code>PEtab.calibrate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calibrate(prob::PEtabODEProblem, x0, alg; kwargs...)::PEtabOptimisationResult</code></pre><p>From starting point <code>x0</code> using optimization algorithm <code>alg</code>, estimate unknown model parameters for <code>prob</code>, and get results as a <code>PEtabOptimisationResult</code>.</p><p><code>x0</code> can be a <code>Vector</code> or a <code>ComponentArray</code>, where the individual parameters must be in the order expected by <code>prob</code>. To get a vector in the correct order, see <a href="../API/#PEtab.get_x"><code>get_x</code></a>.</p><p>A list of available and recommended optimization algorithms (<code>alg</code>) can be found in the documentation. Briefly, supported algorithms are from:</p><ul><li><a href="https://julianlsolvers.github.io/Optim.jl/stable/">Optim.jl</a>: <code>LBFGS()</code>, <code>BFGS()</code>,   or <code>IPNewton()</code> methods.</li><li><a href="https://coin-or.github.io/Ipopt/">Ipopt.jl</a>: <code>IpoptOptimizer()</code> interior-point Newton   method.</li><li><a href="https://github.com/fides-dev/fides">Fides.py</a>: <code>Fides()</code> Newton trust region method.</li></ul><p>Different ways to visualize the parameter estimation result can be found in the documentation.</p><p>See also <a href="../API/#PEtab.PEtabOptimisationResult"><code>PEtabOptimisationResult</code></a>, <a href="../pest_algs/#Fides"><code>Fides</code></a> and <a href="../API/#PEtab.IpoptOptimizer"><code>IpoptOptimizer</code></a></p><p><strong>Keyword Arguments</strong></p><ul><li><code>save_trace::Bool = false</code>: Whether to save the optimization trace of the objective   function and parameter vector. Only applicable for some algorithms; see the   documentation for details.</li><li><code>options = DEFAULT_OPTIONS</code>: Configurable options for <code>alg</code>. The type and available   options depend on which package <code>alg</code> belongs to. For example, if <code>alg = IPNewton()</code>   from Optim.jl, <code>options</code> should be provided as an <code>Optim.Options()</code> struct. A list of   configurable options can be found in the documentation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/aed29b2cc8f19f6309de7bf8126eea0b3e51589c/src/parameter_estimation/singlestart.jl#L1-L31">source</a></section></article><p>For information and recommendations on algorithms (<code>alg</code>), see <a href="../pest_algs/#options_optimizers">this</a> page. For our working example, following the recommendations, we use Optim.jl&#39;s Interior-Point Newton method (<code>IPNewton</code>):</p><pre><code class="language-julia hljs">using Optim
res = calibrate(petab_prob, x0, IPNewton())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">PEtabOptimisationResult</span>
---------------- <span class="sgr1">Summary</span> ---------------
min(f)                = 7.58e+01
Parameters estimated  = 4
Optimiser iterations  = 23
Runtime               = 4.9e-01s
Optimiser algorithm   = Optim_IPNewton
</code></pre><p>The result from <code>calibrate</code> is returned as a <code>PEtabOptimisationResult</code> which holds the relevant statistics from the optimization:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.PEtabOptimisationResult-pest_method" href="#PEtab.PEtabOptimisationResult-pest_method"><code>PEtab.PEtabOptimisationResult</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PEtabOptimisationResult</code></pre><p>Parameter estimation statistics from single-start optimization with <code>calibrate</code>.</p><p>See also: <a href="../API/#PEtab.calibrate"><code>calibrate</code></a></p><p><strong>Fields</strong></p><ul><li><code>xmin</code>: Minimizing parameter vector found by the optimization.</li><li><code>fmin</code>: Minimum objective value found by the optimization.</li><li><code>x0</code>: Starting parameter vector.</li><li><code>alg</code>: Parameter estimation algorithm used.</li><li><code>niterations</code>: Number of iterations for the optimization.</li><li><code>runtime</code>: Runtime in seconds for the optimization.</li><li><code>xtrace</code>: Parameter vector optimization trace. Empty if <code>save_trace = false</code> was   provided to <code>calibrate</code>.</li><li><code>ftrace</code>: Objective function optimization trace. Empty if <code>save_trace = false</code> was   provided to <code>calibrate</code>.</li><li><code>converged</code>: Convergence flag from <code>alg</code>.</li><li><code>original</code>: Original result struct returned by <code>alg</code>. For example, if <code>alg = IPNewton()</code>   from Optim.jl, <code>original</code> is the Optim return struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/aed29b2cc8f19f6309de7bf8126eea0b3e51589c/src/structs/parameter_estimation.jl#L108-L129">source</a></section></article><p>The result from <code>calibrate</code> can also be plotted. For example, to see how well the model fits the data, the fit can be plotted as:</p><pre><code class="language-julia hljs">using Plots
plot(res, petab_prob)</code></pre><img src="2f4d4539.svg" alt="Example block output"/><p>Information on other available plots can be found on <a href="../pest_plot/#optimization_output_plotting">this</a> page. Now, even though the plot above may look good, it is important to remember that the objective function (<span>$-\ell$</span> above) often has multiple local minima. To ensure the global optimum is found, a global optimization approach is needed. One effective global method is multi-start parameter estimation.</p><h2 id="multistart_est"><a class="docs-heading-anchor" href="#multistart_est">Multi-Start Parameter Estimation</a><a id="multistart_est-1"></a><a class="docs-heading-anchor-permalink" href="#multistart_est" title="Permalink"></a></h2><p>Multi-start parameter estimation is an approach where <code>n</code> parameter estimation runs are initiated from <code>n</code> random starting points. The rationale is that a subset of these runs should, hopefully, converge to the global optimum. While simple, empirical benchmark studies have shown that this method performs well for ODE models in biology [<a href="../references/#raue2013lessons">2</a>, <a href="../references/#raue2013lessons">2</a>].</p><p>The first step for multi-start parameter estimation is to generate <code>n</code> starting points. While random uniform sampling may initially seem like a good approach, random points tend to cluster. Instead, it&#39;s better to use a <a href="https://en.wikipedia.org/wiki/Quasi-Monte_Carlo_method">Quasi-Monte Carlo</a> method, such as <a href="https://en.wikipedia.org/wiki/Latin_hypercube_sampling">Latin hypercube sampling</a>, to generate more spread-out starting points. This approach has been shown to improve performance [<a href="../references/#raue2013lessons">2</a>]. The difference can quite clearly be seen generating 100 random points and 50 Latin hypercube-sampled points on the plane.</p><pre><code class="language-julia hljs">using Distributions, QuasiMonteCarlo, Plots
s1 = QuasiMonteCarlo.sample(100, [-1.0, -1.0], [1.0, 1.0], Uniform())
s2 = QuasiMonteCarlo.sample(100, [-1.0, -1.0], [1.0, 1.0], LatinHypercubeSample())
p1 = plot(s1[1, :], s1[2, :], title = &quot;Uniform sampling&quot;, seriestype=:scatter)
p2 = plot(s2[1, :], s2[2, :], title = &quot;Latin Hypercube Sampling&quot;, seriestype=:scatter)
plot(p1, p2)</code></pre><img src="324dee70.svg" alt="Example block output"/><p>For a <code>PEtabODEProblem</code>, Latin hypercube sampled points within the parameter bounds can be generated with the <code>get_startguesses</code> function:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.get_startguesses-pest_method" href="#PEtab.get_startguesses-pest_method"><code>PEtab.get_startguesses</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_startguesses(prob::PEtabODEProblem, n::Integer; kwargs...)</code></pre><p>Generate <code>n</code> random parameter vectors within the parameter bounds in <code>prob</code>.</p><p>If <code>n = 1</code>, a single random vector is returned. For <code>n &gt; 1</code>, a vector of random parameter vectors is returned. In both cases, parameter vectors are returned as a <code>ComponentArray</code>. For details on how to interact with a <code>ComponentArray</code>, see the documentation and the ComponentArrays.jl <a href="https://github.com/jonniedie/ComponentArrays.jl">documentation</a>.</p><p>See also <a href="../API/#PEtab.calibrate"><code>calibrate</code></a> and <a href="../API/#PEtab.calibrate_multistart"><code>calibrate_multistart</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>sampling_method = LatinHypercubeSample()</code>: Method for sampling a diverse (spread out) set  of parameter vectors. Any algorithm from  <a href="https://github.com/SciML/QuasiMonteCarlo.jl">QuasiMonteCarlo</a> is allowed, but the  default <code>LatinHypercubeSample</code> is recommended as it usually performs well.</li><li><code>sample_prior::Bool = true</code>: Whether to sample random parameter values from the  prior distribution if a parameter has a prior.</li><li><code>allow_inf::Bool = false</code>: Whether to return parameter vectors for which the likelihood  cannot be computed (typically happens because the <code>ODEProblem</code> cannot be solved). Often  it only makes sense to use starting points with a computable likelihood for  parameter estimation, hence it typically does not make sense to change this option.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/aed29b2cc8f19f6309de7bf8126eea0b3e51589c/src/parameter_estimation/startguesses.jl#L1-L24">source</a></section></article><p>For our working example, we can generate 50 starting guesses with:</p><pre><code class="language-julia hljs">x0s = get_startguesses(petab_prob, 50)</code></pre><p>In principle, <code>x0s</code> can now be used together with <code>calibrate</code> to perform multi-start parameter estimation. But, to further simplify this process, PEtab.jl provides a convenient function, <code>calibrate_multistart</code>, which combines start-guess generation and parameter estimation in one step:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.calibrate_multistart-pest_method" href="#PEtab.calibrate_multistart-pest_method"><code>PEtab.calibrate_multistart</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calibrate_multistart(prob::PEtabODEProblem, alg, nmultistarts::Integer; nprocs = 1,
                     dirsave=nothing, kwargs...)::PEtabMultistartResult</code></pre><p>Perform <code>nmultistarts</code> parameter estimation runs from randomly sampled starting points using the optimization algorithm <code>alg</code> to estimate the unknown model parameters in <code>prob</code>.</p><p>A list of available and recommended optimisation algorithms (<code>alg</code>) can be found in the package documentation and in the <a href="../API/#PEtab.calibrate"><code>calibrate</code></a> documentation.</p><p>If <code>nprocs &gt; 1</code>, the parameter estimation runs are performed in parallel using the <a href="https://docs.julialang.org/en/v1/stdlib/Distributed/#Distributed.pmap"><code>pmap</code></a> function from Distributed.jl with <code>nprocs</code> processes. If parameter estimation on a single process (<code>nprocs = 1</code>) takes longer than 5 minutes, we <strong>strongly</strong> recommend setting <code>nprocs &gt; 1</code>, as this can greatly reduce runtime. Note that <code>nprocs</code> should not be larger than the number of cores on the computer.</p><p>If <code>dirsave</code> is provided, intermediate results for each run are saved in <code>dirsave</code>. It is <strong>strongly</strong> recommended to provide <code>dirsave</code> for larger models, as parameter estimation can take hours (or even days!),and without <code>dirsave</code>, all intermediate results will be lost if something goes wrong.</p><p>Different ways to visualize the parameter estimation result can be found in the documentation.</p><p>See also <a href="../API/#PEtab.PEtabMultistartResult"><code>PEtabMultistartResult</code></a>, <a href="../API/#PEtab.get_startguesses"><code>get_startguesses</code></a>, and <a href="../API/#PEtab.calibrate"><code>calibrate</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>sampling_method = LatinHypercubeSample()</code>: Method for sampling a diverse (spread out) set  of starting points. See the documentation for <a href="../API/#PEtab.get_startguesses"><code>get_startguesses</code></a>, which is the  function used for sampling.</li><li><code>sample_prior::Bool = true</code>: See the documentation for <a href="../API/#PEtab.get_startguesses"><code>get_startguesses</code></a>.</li><li><code>seed = nothing</code>: Seed used when generating starting points.</li><li><code>options = DEFAULT_OPTIONS</code>: Configurable options for <code>alg</code>. See the documentation for   <a href="../API/#PEtab.calibrate"><code>calibrate</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/aed29b2cc8f19f6309de7bf8126eea0b3e51589c/src/parameter_estimation/multistart.jl#L1-L36">source</a></section></article><p>Two important keyword arguments for <code>calibrate_multistart</code> are <code>dirsave</code> and <code>nprocs</code>. If <code>nprocs &gt; 1</code>, the parameter estimation runs are performed in parallel using the <a href="https://docs.julialang.org/en/v1/stdlib/Distributed/#Distributed.pmap"><code>pmap</code></a> function from Distributed.jl with <code>nprocs</code> processes. Even though <code>pmap</code> introduces some overhead because it must load and compile the code on each process, setting <code>nprocs &gt; 1</code> often reduces runtime when the parameter estimation is expected to take longer than 5 minutes. Meanwhile, <code>dirsave</code> specifies an optional directory to continuously save the results from each individual run. We <strong>strongly recommend</strong> providing such a directory, as parameter estimation for larger models can take hours or even days. If something goes wrong with the computer during that time, it is, to put it mildly, frustrating to lose all the results. For our working example, we can perform 50 multistarts in parallel on two processes with:</p><pre><code class="language-julia hljs">ms_res = calibrate_multistart(petab_prob, IPNewton(), 50; nprocs = 2,
                              dirsave=&quot;path_to_save_directory&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">PEtabMultistartResult</span>
---------------- <span class="sgr1">Summary</span> ---------------
min(f)                = 7.58e+01
Parameters estimated  = 4
Number of multistarts = 50
Optimiser algorithm   = Optim_IPNewton
Results saved at path_to_save_directory
</code></pre><p>The results are returned as a <code>PEtabMultistartResult</code>, which, in addition to printout statistics, contains relevant information for each run:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.PEtabMultistartResult-pest_method" href="#PEtab.PEtabMultistartResult-pest_method"><code>PEtab.PEtabMultistartResult</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PEtabMultistartResult</code></pre><p>Parameter estimation statistics from multi-start optimization with <code>calibrate_multistart</code>.</p><p>See also <a href="../API/#PEtab.calibrate_multistart"><code>calibrate_multistart</code></a> and <a href="../API/#PEtab.PEtabOptimisationResult"><code>PEtabOptimisationResult</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>xmin</code>: Best minimizer across all runs.</li><li><code>fmin</code>: Best minimum across all runs.</li><li><code>alg</code>: Parameter estimation algorithm.</li><li><code>nmultistarts</code>: Number of parameter estimation runs.</li><li><code>sampling_method</code>: Sampling method used for generating starting points.</li><li><code>dirsave</code>: Path of directory where parameter estimation run statistics are saved if   <code>dirsave</code> was provided to <code>calibrate_multistart</code>.</li><li><code>runs</code>: Vector of <code>PEtabOptimisationResult</code> with the parameter estimation results   for each run.</li></ul><pre><code class="nohighlight hljs">PEtabMultistartResult(dirres::String; which_run::String=&quot;1&quot;)</code></pre><p>Import multistart parameter estimation results saved at <code>dirres</code>.</p><p>Each time a new optimization run is performed, results are saved with unique numerical endings. Results from a specific run can be retrieved by specifying the numerical ending with <code>which_run</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/aed29b2cc8f19f6309de7bf8126eea0b3e51589c/src/structs/parameter_estimation.jl#L143-L169">source</a></section></article><p>Finally, a common approach to evaluate the result of multi-start parameter estimation is through plotting. One widely used evaluation plot is the waterfall plot, which shows the final objective values for each run:</p><pre><code class="language-julia hljs">plot(ms_res; plot_type=:waterfall)</code></pre><img src="7cf13136.svg" alt="Example block output"/><p>In the waterfall plot, each plateau corresponds to different local optima (represented by different colors). Since many runs (dots) are found on the plateau with the smallest objective value, we can be confident that the global optimum has been found. In addition to waterfall plots, more plotting options can be found on <a href="../pest_plot/#optimization_output_plotting">this</a> page.</p><h2 id="Creating-an-OptimizationProblem"><a class="docs-heading-anchor" href="#Creating-an-OptimizationProblem">Creating an OptimizationProblem</a><a id="Creating-an-OptimizationProblem-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-an-OptimizationProblem" title="Permalink"></a></h2><p><a href="https://github.com/SciML/Optimization.jl">Optimization.jl</a> is a Julia package that provides a unified interface for over 100 optimization algorithms (see their <a href="https://docs.sciml.ai/Optimization/stable/">documentation</a> for the complete list). While Optimization.jl is undoubtedly useful, it is currently undergoing heavy updates, so at the moment we do not recommend it as the default choice for parameter estimation.</p><p>The central object in Optimization.jl is the <code>OptimizationProblem</code>, and PEtab.jl directly supports converting a <code>PEtabODEProblem</code> into an <code>OptimizationProblem</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PEtab.OptimizationProblem-pest_method" href="#PEtab.OptimizationProblem-pest_method"><code>PEtab.OptimizationProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OptimizationProblem(prob::PEtabODEProblem; box_constraints::Bool = true)</code></pre><p>Create an <a href="https://github.com/SciML/Optimization.jl">Optimization.jl</a> <code>OptimizationProblem</code> from <code>prob</code>.</p><p>To use algorithms not compatible with box constraints (e.g., Optim.jl <code>NewtonTrustRegion</code>), set <code>box_constraints = false</code>. Note that with this option, optimizers may move outside the bounds, which can negatively impact performance. More information on how to use an <code>OptimizationProblem</code> can be found in the Optimization.jl <a href="https://docs.sciml.ai/Optimization/stable/">documentation</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sebapersson/PEtab.jl/blob/aed29b2cc8f19f6309de7bf8126eea0b3e51589c/src/parameter_estimation/singlestart.jl#L34-L45">source</a></section></article><p>For our working example, we can create an <code>OptimizationProblem</code> with:</p><pre><code class="language-julia hljs">using Optimization
opt_prob = OptimizationProblem(petab_prob)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">OptimizationProblem</span>. In-place: <span class="sgr38_2" style="color:#56b6c2">true</span>
u0: ComponentVector{Float64}(log10_c1 = 1.0, log10_c2 = 2.6989704386302837, log10_S0 = 2.6989704386302837, log10_sigma = 2.6989704386302837)</code></pre><p>Given a start-guess <code>x0</code>, we can then estimate the parameters using, for example, Optim.jl&#39;s <code>ParticleSwarm()</code> method, with:</p><pre><code class="language-julia hljs">using OptimizationOptimJL
opt_prob.u0 .= x0
res = solve(opt_prob, Optim.ParticleSwarm())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Failure
u: ComponentVector{Float64}(log10_c1 = 1.9645945812029193, log10_c2 = 3.0, log10_S0 = 1.9998090325686793, log10_sigma = 0.0629146867411708)</code></pre><p>which returns an <code>OptimizationSolution</code>. For more information on options and how to interact with <code>OptimizationSolution</code>, see the Optimization.jl <a href="https://docs.sciml.ai/Optimization/stable/">documentation</a>.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><div class="citation noncanonical"><dl><dt>[2]</dt><dd><div>A. Raue, M. Schilling, J. Bachmann, A. Matteson, M. Schelke, D. Kaschek, S. Hug, C. Kreutz, B. D. Harms, F. J. Theis and others. <em>Lessons learned from quantitative dynamical modeling in systems biology</em>. PloS one <strong>8</strong>, e74335 (2013).</div></dd><dt>[3]</dt><dd><div>H. Hass, C. Loos, E. Raimundez-Alvarez, J. Timmer, J. Hasenauer and C. Kreutz. <em>Benchmark problems for dynamic modeling of intracellular processes</em>. Bioinformatics <strong>35</strong>, 3073–3082 (2019).</div></dd><dt>[9]</dt><dd><div>A. F. Villaverde, D. Pathirana, F. Fröhlich, J. Hasenauer and J. R. Banga. <em>A protocol for dynamic model calibration</em>. Briefings in bioinformatics <strong>23</strong>, bbab387 (2022).</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../import_petab/">« Importing PEtab Standard Format</a><a class="docs-footer-nextpage" href="../pest_plot/">Plotting Estimation Results »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Saturday 12 July 2025 11:30">Saturday 12 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
