<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · PEtab.jl</title><meta name="title" content="Tutorial · PEtab.jl"/><meta property="og:title" content="Tutorial · PEtab.jl"/><meta property="twitter:title" content="Tutorial · PEtab.jl"/><meta name="description" content="Documentation for PEtab.jl."/><meta property="og:description" content="Documentation for PEtab.jl."/><meta property="twitter:description" content="Documentation for PEtab.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom_theme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PEtab.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Input-Problem"><span>Input Problem</span></a></li><li><a class="tocitem" href="#Creating-the-Parameter-Estimation-Problem"><span>Creating the Parameter Estimation Problem</span></a></li><li><a class="tocitem" href="#Parameter-estimation"><span>Parameter estimation</span></a></li><li><a class="tocitem" href="#Next-Steps"><span>Next Steps</span></a></li><li><a class="tocitem" href="#Copy-Pasteable-Example"><span>Copy Pasteable Example</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Extended Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../petab_simcond/">Simulation conditions</a></li><li><a class="tocitem" href="../petab_preeq_simulations/">Steady-State Simulations (Pre-Equilibration)</a></li><li><a class="tocitem" href="../petab_event/">Events (callbacks, dosages, etc.)</a></li><li><a class="tocitem" href="../petab_cond_specific/">Simulation Condition-Specific Parameters</a></li><li><a class="tocitem" href="../petab_obs_noise/">Noise and Observable Parameters</a></li><li><a class="tocitem" href="../import_petab/">Importing PEtab Standard Format</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Parameter Estimation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../pest_method/">Parameter Estimation Methods</a></li><li><a class="tocitem" href="../pest_plot/">Plotting Estimation Results</a></li><li><a class="tocitem" href="../pest_algs/">Available and Recommended Algorithms</a></li><li><a class="tocitem" href="../pest_select/">Model Selection with PEtab-select</a></li><li><a class="tocitem" href="../pest_custom/">Wrapping Optimization Packages</a></li></ul></li><li><a class="tocitem" href="../inference/">Bayesian Inference</a></li><li><a class="tocitem" href="../API/">API</a></li><li><a class="tocitem" href="../grad_hess_methods/">Gradient and Hessian Methods</a></li><li><a class="tocitem" href="../default_options/">Default Options</a></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Performance Tips</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../nonstiff_models/">Non-Biology (Non-Stiff) Models</a></li><li><a class="tocitem" href="../Beer/">Condition-Specific Parameters</a></li><li><a class="tocitem" href="../Bachmann/">Adjoint Sensitivity Analysis (Large Models)</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li><li><a class="tocitem" href="../FAQ/">FAQ</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/sebapersson/PEtab.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/sebapersson/PEtab.jl/blob/main/docs/src/tutorial.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="tutorial"><a class="docs-heading-anchor" href="#tutorial">Tutorial</a><a id="tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial" title="Permalink"></a></h1><p>This overarching tutorial of PEtab.jl covers how to create a parameter estimation problem in Julia (a <code>PEtabODEProblem</code>) and how to estimate the unknown parameters for the created problem.</p><h2 id="Input-Problem"><a class="docs-heading-anchor" href="#Input-Problem">Input Problem</a><a id="Input-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Input-Problem" title="Permalink"></a></h2><p>As a working example, this tutorial considers the Michaelis-Menten enzyme kinetics chemical reaction model:</p><p class="math-container">\[S + E \xrightarrow{c_1} SE \\
SE \xrightarrow{c_2} S + E \\
SE \xrightarrow{c_3} S + P,\]</p><p>Which, via the <a href="https://en.wikipedia.org/wiki/Law_of_mass_action">law of mass action</a>, can be converted to a system of Ordinary Differential Equations (ODEs):</p><p class="math-container">\[\begin{align*}
    \frac{\mathrm{d}S}{\mathrm{d}t} &amp;= c_1 S \cdot E - c_2 SE \\
    \frac{\mathrm{d}E}{\mathrm{d}t} &amp;= c_1 S \cdot E - c_2 SE \\
    \frac{\mathrm{d}SE}{\mathrm{d}t} &amp;= -c_1 S \cdot E + c_2 SE - c_3 SE \\
    \frac{\mathrm{d}P}{\mathrm{d}t} &amp;= c_3 SE
\end{align*}\]</p><p>For the working example, we assume that the initial values for the species <code>[S, E, SE, P]</code> are:</p><p class="math-container">\[S(t_0) = S_0, \quad E(t_0) = 50.0, \quad SE(t_0) = 0.0, \quad P(t_0) = 0.0\]</p><p>And that the observables for which we have time-lapse measurement data are the sum of <code>S + E</code> as well as <code>P</code>:</p><p class="math-container">\[\begin{align*}
    obs_1 &amp;= S + E \\
    obs_2 &amp;= P
\end{align*}\]</p><p>For the parameter estimation, we aim to estimate the parameters <code>[c1, c2]</code> and the initial value <code>S(t_0) = S0</code> (a total of three parameters), while assuming <code>c3 = 1.0</code> is known. This tutorial demonstrates how to set up this parameter estimation problem (create a <code>PEtabODEProblem</code>) and estimate parameters using <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a>.</p><h2 id="Creating-the-Parameter-Estimation-Problem"><a class="docs-heading-anchor" href="#Creating-the-Parameter-Estimation-Problem">Creating the Parameter Estimation Problem</a><a id="Creating-the-Parameter-Estimation-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-the-Parameter-Estimation-Problem" title="Permalink"></a></h2><p>To define a parameter estimation problem we need four components:</p><ol><li><strong>Dynamic Model</strong>: The dynamic model can be provided as either a <a href="https://petab.readthedocs.io/en/latest/">Catalyst.jl</a> <code>ReactionSystem</code> or a <a href="https://github.com/SciML/ModelingToolkit.jl">ModellingToolkit.jl</a> <code>ODESystem</code>.</li><li><strong>Observable Formulas</strong>: To link the model to the measurement data, we need observable formulas. Since real-world data often comes with measurement noise, PEtab also requires that noise formulas and noise distributions are provided for each observable. All of this is specified with the <code>PEtabObservable</code>.</li><li><strong>Parameters to Estimate</strong>: A parameter estimation problem needs parameters to be estimated. Since often only a subset of the dynamic model parameters is estimated, PEtab explicitly requires that the parameters to be estimated are specified as a <code>PEtabParameter</code>. It is also possible to set priors on these parameters.</li><li><strong>Measurement Data</strong>: To estimate parameters, measurement data is required. This data should be provided as a <code>DataFrame</code> in the format explained below.</li><li><strong>Simulation Conditions (Optional)</strong>: Measurements are often collected under various experimental conditions, which correspond to different simulation conditions. Details on how to handle such conditions are provided in <a href="../petab_simcond/#petab_sim_cond">this</a> tutorial.</li></ol><h3 id="Defining-the-Dynamic-Model"><a class="docs-heading-anchor" href="#Defining-the-Dynamic-Model">Defining the Dynamic Model</a><a id="Defining-the-Dynamic-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-Dynamic-Model" title="Permalink"></a></h3><p>The dynamic model can be either a <a href="https://github.com/SciML/Catalyst.jl">Catalyst.jl</a> <code>ReactionSystem</code> or a <a href="https://github.com/SciML/ModelingToolkit.jl">ModelingToolkit.jl</a> <code>ODESystem</code>. For the Michaelis-Menten model above, the Catalyst representation is given by:</p><pre><code class="language-julia hljs">using Catalyst
t = default_t()
rn = @reaction_network begin
    @parameters S0 c3=1.0
    @species S(t)=S0
    c1, S + E --&gt; SE
    c2, SE --&gt; S + E
    c3, SE --&gt; P + E
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{S} + \mathrm{E} &amp;\xrightleftharpoons[c2]{c1} \mathrm{SE} \\
\mathrm{SE} &amp;\xrightarrow{c3} \mathrm{P} + \mathrm{E}  
 \end{align*}
 \]</p><p>Parameters that are constant (<code>c3</code>) and those that set initial values (<code>S0</code>) should be defined in the <code>parameters</code> block. Values for parameters that are to be estimated (here <code>[c1, c2, S0]</code>) do not need to be specified. Similarly, for species, only those with a parameter-dependent initial value need to be defined in the <code>species</code> block, while species with a constant initial value can be defined directly in the system (similar to <code>c3</code> above) or as a specie map:</p><pre><code class="language-julia hljs">speciemap = [:E =&gt; 50.0, :SE =&gt; 0.0, :P =&gt; 0.0]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Pair{Symbol, Float64}}:
  :E =&gt; 50.0
 :SE =&gt; 0.0
  :P =&gt; 0.0</code></pre><p>Any species or parameters with undeclared initial values default to 0. For additional details on how to create a <code>ReactionSystem</code>, see the excellent Catalyst <a href="https://docs.sciml.ai/Catalyst/stable/">documentation</a>.</p><p>Using a ModelingToolkit <code>ODESystem</code>, the model is defined as:</p><pre><code class="language-julia hljs">using ModelingToolkit
using ModelingToolkit: t_nounits as t, D_nounits as D
@mtkmodel SYS begin
    @parameters begin
        S0
        c1
        c2
        c3 = 1.0
    end
    @variables begin
        S(t) = S0
        E(t) = 50.0
        SE(t) = 0.0
        P(t) = 0.0
    end
    @equations begin
        D(S) ~ -c1 * S * E + c2 * SE
        D(E) ~ -c1 * S * E + c2 * SE + c3 * SE
        D(SE) ~ c1 * S * E - c2 * SE - c3 * SE
        D(P) ~ c3 * SE
    end
end
@mtkbuild sys = SYS()</code></pre><p class="math-container">\[ \begin{align}
\frac{\mathrm{d} S\left( t \right)}{\mathrm{d}t} &amp;= c2 \mathrm{SE}\left( t \right) - c1 E\left( t \right) S\left( t \right) \\
\frac{\mathrm{d} E\left( t \right)}{\mathrm{d}t} &amp;= c2 \mathrm{SE}\left( t \right) + c3 \mathrm{SE}\left( t \right) - c1 E\left( t \right) S\left( t \right) \\
\frac{\mathrm{d} \mathrm{SE}\left( t \right)}{\mathrm{d}t} &amp;=  - c2 \mathrm{SE}\left( t \right) - c3 \mathrm{SE}\left( t \right) + c1 E\left( t \right) S\left( t \right) \\
\frac{\mathrm{d} P\left( t \right)}{\mathrm{d}t} &amp;= c3 \mathrm{SE}\left( t \right)
\end{align}
 \]</p><p>For an <code>ODESystem</code>, all parameters and species must be declared in the <code>@mtkmodel</code> block. If the value of a parameter or species is left empty (e.g., <code>c2</code> above) and the parameter is not set to be estimated, it defaults to 0. For additional details on how to create an <code>ODESystem</code> model, see the ModelingToolkit <a href="https://docs.sciml.ai/ModelingToolkit/dev/">documentation</a>.</p><h3 id="Defining-the-Observables"><a class="docs-heading-anchor" href="#Defining-the-Observables">Defining the Observables</a><a id="Defining-the-Observables-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-Observables" title="Permalink"></a></h3><p>To connect the model with measurement data, we need an observable formula. Additionally, since measurement data is typically noisy, PEtab requires a measurement noise formula.</p><p>For example, let us assume we have observed the sum <code>E + S</code> (<span>$obs_1$</span> above) with a known normally distributed measurement error (<code>σ = 3.0</code>). This in encoded as:</p><pre><code class="language-julia hljs">using PEtab
@unpack E, S = rn
obs_sum = PEtabObservable(S + E, 3.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">PEtabObservable:</span> <span class="sgr34">h</span> = E(t) + S(t) and <span class="sgr34">sd</span> = 3.0 with normal measurement noise</code></pre><p>In <code>PEtabObservable</code>, the first argument is the observed formula, and the second argument is the formula for the measurement error. In this case, we assumed a known measurement error (<code>σ = 3.0</code>), but often the measurement error is unknown and needs to be estimated. For example, let us assume we have observed <code>P</code> (<span>$obs_2$</span>) with an unknown measurement error <code>sigma</code>. This in encoded as:</p><pre><code class="language-julia hljs">@unpack P = rn
@parameters sigma
obs_p = PEtabObservable(P, sigma)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">PEtabObservable:</span> <span class="sgr34">h</span> = P(t) and <span class="sgr34">sd</span> = sigma with normal measurement noise</code></pre><p>By defining <code>sigma</code> as a <code>PEtabParameter</code> (explained below), it is estimated along with the other parameters. To complete the definition of the observables, we need to group all <code>PEtabObservable</code>s together into a <code>Dict</code> and assign an appropriate name for each observable:</p><pre><code class="language-julia hljs">observables = Dict(&quot;obs_p&quot; =&gt; obs_p, &quot;obs_sum&quot; =&gt; obs_sum)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, PEtabObservable} with 2 entries:
  &quot;obs_p&quot;   =&gt; <span class="sgr1">PEtabObservable:</span> <span class="sgr34">h</span> = P(t) and <span class="sgr34">sd</span> = sigma with normal measurement…
  &quot;obs_sum&quot; =&gt; <span class="sgr1">PEtabObservable:</span> <span class="sgr34">h</span> = E(t) + S(t) and <span class="sgr34">sd</span> = 3.0 with normal measur…</code></pre><p>More formally, a <code>PEtabObservable</code> defines a likelihood function for an observable. By default, a normally distributed error and corresponding likelihood is assumed, but log-normal distribution is also supported. For more details, see the <a href="../API/#API">API</a>.</p><h3 id="Defining-Parameters-to-Estimate"><a class="docs-heading-anchor" href="#Defining-Parameters-to-Estimate">Defining Parameters to Estimate</a><a id="Defining-Parameters-to-Estimate-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Parameters-to-Estimate" title="Permalink"></a></h3><p>To set up a parameter estimation problem, we need to specify the parameters to estimate via <code>PEtabParameter</code>. To set <code>c1</code> to be estimated, use:</p><pre><code class="language-julia hljs">p_c1 = PEtabParameter(:c1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">PEtabParameter:</span> <span class="sgr34">c1</span> estimated on log10-scale with bounds [1.0e-03, 1.0e+03]</code></pre><p>From the printout, we see that by default <code>c1</code> is assigned bounds <code>[1e-3, 1e3]</code>. This is because benchmarks have shown that using bounds is advantageous, as it prevents simulation failures during parameter estimation[<a href="../references/#frohlich2022fides">1</a>]. Furthermore, we see that by default <code>c1</code> is estimated on a <code>log10</code> scale. Benchmarks have demonstrated that estimating parameters on a <code>log10</code> scale improves performance [<a href="../references/#raue2013lessons">2</a>, <a href="../references/#hass2019benchmark">3</a>]. Naturally, it is possible to change the bounds and/or scale; see the <a href="../API/#API">API</a> for details.</p><p>When specifying a <code>PEtabParameter</code> we can also provide prior information. For example, assume we know that <code>c2</code> should have a value around 10. To account for this we can provide a <a href="https://en.wikipedia.org/wiki/Prior_probability">prior</a> for the parameter using any continuous distribution from <a href="https://github.com/JuliaStats/Distributions.jl">Distributions.jl</a>. For example, to assign a <code>Normal(10.0, 0.3)</code> prior to <code>c2</code>, do:</p><pre><code class="language-julia hljs">using Distributions
p_c2 = PEtabParameter(:c2; prior = Normal(10.0, 0.3))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">PEtabParameter:</span> <span class="sgr34">c2</span> estimated on log10-scale with bounds [1.0e-03, 1.0e+03] and prior Normal(μ=10.0, σ=0.3)</code></pre><p>By default, the prior is on a linear scale (not the default <code>log10</code> scale), but this can be changed if needed. For more details, see the <a href="../API/#API">API</a>.</p><p>To complete the definition of the parameters to estimate, we need to assign a <code>PEtabParameter</code> for each unknown and group them into a <code>Vector</code>:</p><pre><code class="language-julia hljs">p_s0 = PEtabParameter(:S0)
p_sigma = PEtabParameter(:sigma)
pest = [p_c1, p_c2, p_s0, p_sigma]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{PEtabParameter}:
 <span class="sgr1">PEtabParameter:</span> <span class="sgr34">c1</span> estimated on log10-scale with bounds [1.0e-03, 1.0e+03]
 <span class="sgr1">PEtabParameter:</span> <span class="sgr34">c2</span> estimated on log10-scale with bounds [1.0e-03, 1.0e+03] and prior Normal(μ=10.0, σ=0.3)
 <span class="sgr1">PEtabParameter:</span> <span class="sgr34">S0</span> estimated on log10-scale with bounds [1.0e-03, 1.0e+03]
 <span class="sgr1">PEtabParameter:</span> <span class="sgr34">sigma</span> estimated on log10-scale with bounds [1.0e-03, 1.0e+03]</code></pre><h3 id="Measurement-Data-Format"><a class="docs-heading-anchor" href="#Measurement-Data-Format">Measurement Data Format</a><a id="Measurement-Data-Format-1"></a><a class="docs-heading-anchor-permalink" href="#Measurement-Data-Format" title="Permalink"></a></h3><p>The measurement data should be provided in a <code>DataFrame</code> with the following format (the column names matter, but not the order):</p><table><tr><th style="text-align: right">obs_id (str)</th><th style="text-align: right">time (float)</th><th style="text-align: right">measurement (float)</th></tr><tr><td style="text-align: right">id</td><td style="text-align: right">val</td><td style="text-align: right">val</td></tr><tr><td style="text-align: right">...</td><td style="text-align: right">...</td><td style="text-align: right">...</td></tr></table><p>Where the columns correspond to:</p><ul><li><code>obs_id</code>: The observable to which the measurement corresponds. It must match one of the <code>keys</code> in the <code>PEtabObservable</code> <code>Dict</code>.</li><li><code>time</code>: The time point at which the measurement was collected.</li><li><code>measurement</code>: The measurement value.</li></ul><p>For our working example, using simulated data, a valid measurement table would look like:</p><pre><code class="language-julia hljs">using OrdinaryDiffEq, DataFrames
# Simulate with &#39;true&#39; parameters
ps = [:c1 =&gt; 1.0, :c2 =&gt; 10.0, :c3 =&gt; 1.0, :S0 =&gt; 100.0]
u0 = [:S =&gt; 100.0, :E =&gt; 50.0, :SE =&gt; 0.0, :P =&gt; 0.0]
tspan = (0.0, 10.0)
oprob = ODEProblem(rn, u0, tspan, ps)
sol = solve(oprob, Rodas5P(); saveat = 0:0.5:10.0)
obs_sum = (sol[:S] + sol[:E]) .+ randn(length(sol[:E]))
obs_p = sol[:P] .+ randn(length(sol[:P]))
df_sum = DataFrame(obs_id = &quot;obs_sum&quot;, time = sol.t, measurement = obs_sum)
df_p = DataFrame(obs_id = &quot;obs_p&quot;, time = sol.t, measurement = obs_p)
measurements = vcat(df_sum, df_p)</code></pre><div><div style = "float: left;"><span>5×3 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowNumber" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">obs_id</th><th style = "text-align: left;">time</th><th style = "text-align: left;">measurement</th></tr><tr class = "subheader headerLastRow"><th class = "rowNumber" style = "font-weight: bold; text-align: right;"></th><th title = "String" style = "text-align: left;">String</th><th title = "Float64" style = "text-align: left;">Float64</th><th title = "Float64" style = "text-align: left;">Float64</th></tr></thead><tbody><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">obs_sum</td><td style = "text-align: right;">0.0</td><td style = "text-align: right;">148.224</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: left;">obs_sum</td><td style = "text-align: right;">0.5</td><td style = "text-align: right;">52.1101</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: left;">obs_sum</td><td style = "text-align: right;">1.0</td><td style = "text-align: right;">41.1324</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">4</td><td style = "text-align: left;">obs_sum</td><td style = "text-align: right;">1.5</td><td style = "text-align: right;">35.463</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">5</td><td style = "text-align: left;">obs_sum</td><td style = "text-align: right;">2.0</td><td style = "text-align: right;">38.0137</td></tr></tbody></table></div><p>It is important to note that the measurement table follows a <a href="https://r4ds.hadley.nz/data-tidy">tidy</a> format [<a href="../references/#wickham2014tidy">4</a>], where each row corresponds to <strong>one</strong> measurement. Therefore, for repeated measurements at a single time point, one row should be added for each repeat.</p><h3 id="Bringing-It-All-Together"><a class="docs-heading-anchor" href="#Bringing-It-All-Together">Bringing It All Together</a><a id="Bringing-It-All-Together-1"></a><a class="docs-heading-anchor-permalink" href="#Bringing-It-All-Together" title="Permalink"></a></h3><p>Given a model, observables, parameters to estimate, and measurement data, it is possible to create a <code>PEtabODEProblem</code>, which contains all the information needed for parameter estimation. This is done in a two-step process, where the first step is to create a <code>PEtabModel</code>. For our <code>ReactionSystem</code> or <code>ODESystem</code> model, this is done as:</p><pre><code class="language-julia hljs">model_sys = PEtabModel(sys, observables, measurements, pest)
model_rn = PEtabModel(rn, observables, measurements, pest; speciemap = speciemap)</code></pre><p>Note that any potential <code>speciemap</code> or <code>parametermap</code> must be provided as a keyword. Given a <code>PEtabModel</code>, it is straightforward to create a <code>PEtabODEProblem</code>:</p><pre><code class="language-julia hljs">petab_prob = PEtabODEProblem(model_rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">PEtabODEProblem:</span> <span class="sgr34">ReactionSystemModel</span> with ODE-states 4 and 4 parameters to estimate
---------------- <span class="sgr1">Problem options</span> ---------------
Gradient method: <span class="sgr34">ForwardDiff</span>
Hessian method: <span class="sgr34">ForwardDiff</span>
ODE-solver nllh: <span class="sgr34">Rodas5P</span>
ODE-solver gradient: <span class="sgr34">Rodas5P</span></code></pre><p>The printout shows relevant statistics for the <code>PEtabODEProblem</code>. First, we see that there are 4 parameters to estimate. Additionally, we see that the ODE solver used for simulating the model is the stiff <code>Rodas5P</code> solver, and that both the gradient and Hessian are computed via forward-mode automatic differentiation using <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a>. These <a href="../default_options/#default_options">defaults</a> are based on extensive benchmarks and typically do not need to be changed for models in biology. For models outside of biology, a discussion of the options can be found <a href="../default_options/#default_options">here</a>. While the defaults generally perform well, they are not always perfect. Therefore, when creating a <code>PEtabODEProblem</code>, anything from the <code>ODESolver</code> to the gradient methods can be customized. For details, see the <a href="../API/#API">API</a>.</p><p>Overall, the <code>PEtabODEProblem</code> contains all the information needed for performing parameter estimation. Next, this tutorial covers how to estimate unknown model parameters given a <code>PEtabODEProblem</code>.</p><h2 id="Parameter-estimation"><a class="docs-heading-anchor" href="#Parameter-estimation">Parameter estimation</a><a id="Parameter-estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-estimation" title="Permalink"></a></h2><p>A <code>PEtabODEProblem</code> (which we defined above) contains all the information needed to wrap a numerical optimization library to perform parameter estimation, and details on how to do this can be found <a href="../pest_custom/#wrap_est">here</a>. However, wrapping existing optimization libraries is cumbersome, therefore PEtab.jl provides wrappers for <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a>, <a href="https://coin-or.github.io/Ipopt/">Ipopt</a>, <a href="https://github.com/SciML/Optimization.jl">Optimization.jl</a>, and <a href="https://github.com/fides-dev/fides">Fides.py</a>.</p><p>This section of the tutorial covers how to use Optim.jl to estimate parameters given a starting guess <code>x0</code>. Moreover, since the objective function to minimize for ODE models often contains multiple local minima, the tutorial also covers how to perform global optimization using multistart parameter estimation.</p><h3 id="Single-Start-Parameter-Estimation"><a class="docs-heading-anchor" href="#Single-Start-Parameter-Estimation">Single-Start Parameter Estimation</a><a id="Single-Start-Parameter-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Single-Start-Parameter-Estimation" title="Permalink"></a></h3><p>To perform parameter estimation with a numerical optimization algorithm, we typically need a starting point <code>x0</code>, where it is important that <code>x0</code> follows the parameter order expected by the <code>PEtabODEProblem</code>. One way to obtain such a vector is by retrieving the <code>PEtabODEProblem</code>&#39;s vector of nominal values, which correspond to the optional parameter values specified in <code>PEtabParameter</code> (if unspecified, these values default to the mean of the lower and upper bounds). This vector can be retrieved with <code>get_x</code>:</p><pre><code class="language-julia hljs">x0 = get_x(petab_prob)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ComponentVector{Float64}(log10_c1 = 2.6989704386302837, log10_c2 = 2.6989704386302837, log10_S0 = 2.6989704386302837, log10_sigma = 2.6989704386302837)</code></pre><p>From the printout we see that <code>x0</code> is a <code>ComponentArray</code>, so in addition to the parameter values, it also holds the parameter names. Additionally, we see that parameters like <code>log10_c1</code> have a <code>log10</code> prefix. This is because the parameter (by default) is estimated on the <code>log10</code> scale, which, as mentioned above, often improves parameter estimation performance [<a href="../references/#hass2019benchmark">3</a>]. Consequently, when changing the value for this parameter, the new value should be provided on the <code>log10</code> scale. For example, to change <code>c1</code> to <code>10.0</code> do:</p><pre><code class="language-julia hljs">x0.log10_c1 = log10(10.0)</code></pre><p>For more details on how to interact with a <code>ComponentArray</code>, see the ComponentArrays.jl <a href="https://github.com/jonniedie/ComponentArrays.jl">documentation</a>. <code>get_x</code> is not the only way, and generally not the recommended way to retrieve a starting point. To avoid biasing the parameter estimation, it is recommended to use a random starting guess within the parameter bounds. This can be generated with <code>get_startguesses</code>:</p><pre><code class="language-julia hljs">x0 = get_startguesses(petab_prob, 1)</code></pre><p>Given a starting point <code>x0</code>, we can now perform the parameter estimation. As this is a small problem with only 4 parameters to estimate, we use the Interior-point Newton method from Optim.jl (for algorithm recommendations, see <a href="../pest_algs/#options_optimizers">this</a> page):</p><pre><code class="language-julia hljs">using Optim
res = calibrate(petab_prob, x0, IPNewton())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">PEtabOptimisationResult</span>
---------------- <span class="sgr1">Summary</span> ---------------
min(f)                = 7.46e+01
Parameters estimated  = 4
Optimiser iterations  = 41
Runtime               = 6.4e-01s
Optimiser algorithm   = Optim_IPNewton
</code></pre><p>The printout shows parameter estimation statistics, such as the final objective value <code>fmin</code> (which, since PEtab works with likelihoods, corresponds to the negative log-likelihood). We can further obtain the minimizing parameter vector:</p><pre><code class="language-julia hljs">res.xmin</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ComponentVector{Float64}(log10_c1 = 0.00693610671805356, log10_c2 = 1.000053748021813, log10_S0 = 1.999909858119594, log10_sigma = 0.01485008202661754)</code></pre><p>This vector is close to the true parameters used to simulate the data above. For information on additional statistics stored in <code>res</code>, see the <a href="../API/#API">API</a> on <code>PEtabOptimisationResult</code>.</p><p>Lastly, to evaluate the parameter estimation, it is useful to plot how well the model fits the data. Using the built-in plotting functionality in PEtab, this is straightforward:</p><pre><code class="language-julia hljs">using Plots
plot(res, petab_prob; linewidth = 2.0)</code></pre><img src="e998474a.svg" alt="Example block output"/><p>Even though the plot looks good, it is important to remember that ODE models often have multiple local minima [<a href="../references/#raue2013lessons">2</a>]. To ensure the global optimum is found, a global optimization approach is required. One effective method is multi-start parameter estimation, which we cover next.</p><h3 id="Multi-Start-Parameter-Estimation"><a class="docs-heading-anchor" href="#Multi-Start-Parameter-Estimation">Multi-Start Parameter Estimation</a><a id="Multi-Start-Parameter-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-Start-Parameter-Estimation" title="Permalink"></a></h3><p>In multi-start parameter estimation, <code>n</code> parameter estimation runs are initiated from <code>n</code> random starting points. The rationale is that a subset of these runs should converge to the global optimum, and even though this is a simple global optimization approach, benchmarks have shown that it performs well for ODE models in biology [<a href="../references/#raue2013lessons">2</a>, <a href="../references/#villaverde2019benchmarking">5</a>].</p><p>The first step in multi-start parameter estimation is to generate <code>n</code> starting points. Simple uniform sampling is not preferred, as randomly generated points tend to cluster. Instead, a <a href="https://en.wikipedia.org/wiki/Quasi-Monte_Carlo_method">Quasi-Monte Carlo</a> method, such as <a href="https://en.wikipedia.org/wiki/Latin_hypercube_sampling">Latin hypercube sampling</a>, is better suited to generate well-spread starting points. In <code>get_startguesses</code>, <code>LatinHypercubeSample</code> is the default method used. Therefore, <code>n = 50</code> Latin hypercube-sampled starting points can be generated with:</p><pre><code class="language-julia hljs">x0s = get_startguesses(petab_prob, 50)</code></pre><p>Besides <code>LatinHypercubeSample</code>, <code>get_startguesses</code> also supports other sampling methods; for details, see the <a href="../API/#API">API</a>. Given our starting points, we can perform multi-start parameter estimation:</p><pre><code class="language-julia hljs">res = Any[]
for x0 in x0s
    push!(res, calibrate(petab_prob, x0, IPNewton()))
end</code></pre><p>As manually generating start guesses and calling <code>calibrate</code> can be cumbersome, PEtab.jl provides a convenience function, <code>calibrate_multistart</code>. For example, to run <code>n = 50</code> multistarts, do:</p><pre><code class="language-julia hljs">ms_res = calibrate_multistart(petab_prob, IPNewton(), 50)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">PEtabMultistartResult</span>
---------------- <span class="sgr1">Summary</span> ---------------
min(f)                = 7.46e+01
Parameters estimated  = 4
Number of multistarts = 50
Optimiser algorithm   = Optim_IPNewton
</code></pre><p>The printout shows parameter estimation statistics, such as the best objective value <code>fmin</code> across all runs. For further details on what is stored in <code>ms_res</code> see the <a href="../API/#API">API</a> documentation for <code>PEtabMultistartResult</code>.</p><p>Following multi-start parameter estimation, it is important to evaluate the results. One common evaluation approach is plotting, and a frequently used evaluation plot is the waterfall plot, which in a sorted manner shows the final objective values for each run:</p><pre><code class="language-julia hljs">plot(ms_res; plot_type=:waterfall)</code></pre><img src="763afb55.svg" alt="Example block output"/><p>In the waterfall plot, each plateau corresponds to different local optima. Since many runs (dots) are found on the plateau with the smallest objective value, we can be confident that the global optimum has been found. Further, we can check how well the best run fits the data:</p><pre><code class="language-julia hljs">plot(ms_res, petab_prob; linewidth = 2.0)</code></pre><img src="e78397a3.svg" alt="Example block output"/><h2 id="Next-Steps"><a class="docs-heading-anchor" href="#Next-Steps">Next Steps</a><a id="Next-Steps-1"></a><a class="docs-heading-anchor-permalink" href="#Next-Steps" title="Permalink"></a></h2><p>This overarching tutorial provides an overview of how to create a parameter estimation problem in Julia. As an introduction, it showcases only a subset of the features supported by PEtab.jl for creating parameter estimation problems. In the extended tutorials, you will find how to handle:</p><ul><li><strong>Simulation conditions</strong>: Sometimes data is gathered under various experimental conditions, where, for example, the initial concentration of a substrate differs between condition. To learn how to setup a problem with such simulation conditions see <a href="../petab_simcond/#petab_sim_cond">this</a> tutorial.</li><li><strong>Steady-State Initialization</strong>: Sometimes the model should be at a steady state at time zero, before it is simulated and compared against data. To learn how to set up a problem with such pre-equilibration criteria, see <a href="../petab_preeq_simulations/#define_with_ss">this</a> tutorial.</li><li><strong>Events</strong>: Sometimes a model may incorporate events like substrate addition at specific time points or parameter changes when a state/species reaches a certain value. To learn how to add model events see <a href="../petab_event/#define_events">this</a> tutorial.</li><li><strong>Condition-Specific System/Model Parameters</strong>: Sometimes a subset of model parameters to estimate, such as protein synthesis rates, varies between simulation conditions, while other parameters remain constant across all conditions. To learn how to handle condition-specific parameters, see <a href="../petab_cond_specific/#define_conditions">this</a> tutorial.</li><li><strong>Time-Point Specific Parameters</strong>: Sometimes one observable is measured with different assays. This can be handled by introducing different observable parameters (e.g., scale and offset) and noise parameters for different measurements. To learn how to add time-point-specific measurement and noise parameters, see <a href="../petab_obs_noise/#time_point_parameters">this</a> tutorial.</li><li><strong>Import PEtab Models</strong>: PEtab is a standard table-based format for parameter estimation. If a problem is provided in this standard format, PEtab.jl can import it directly. To learn how to import models in the standard format, see <a href="../import_petab/#import_petab_problem">this</a> tutorial.</li></ul><p>Besides creating a parameter estimation problem, this overarching tutorial demonstrated how to perform parameter estimation using <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a>. In addition, PEtab.jl also supports using <a href="https://coin-or.github.io/Ipopt/">Ipopt</a>, <a href="https://github.com/SciML/Optimization.jl">Optimization.jl</a>, and <a href="https://github.com/fides-dev/fides">Fides.py</a>. More information on available algorithms for parameter estimation can be found on <a href="../pest_method/#pest_methods">this</a> page. Besides frequentist parameter estimation, PEtab.jl also supports Bayesian inference with state-of-the-art samplers such as <a href="https://github.com/TuringLang/Turing.jl">NUTS</a> (the same sampler used in <a href="https://github.com/TuringLang/Turing.jl">Turing.jl</a>) and <a href="https://github.com/mvihola/AdaptiveMCMC.jl">AdaptiveMCMC.jl</a>. For more information, see the Bayesian inference [page].</p><p>Lastly, when creating a <code>PEtabODEProblem</code> there are many configurable options (see the <a href="../API/#API">API</a>). The default options are based on extensive benchmarks for dynamic models in biology, see <a href="../default_options/#default_options">this</a> page. For how to configure models outside of biology, see <a href="../nonstiff_models/#nonstiff_models">this</a> page. Additionally, for a discussion on available gradient and Hessian methods, see <a href="../grad_hess_methods/#gradient_support">this</a> page.</p><h2 id="Copy-Pasteable-Example"><a class="docs-heading-anchor" href="#Copy-Pasteable-Example">Copy Pasteable Example</a><a id="Copy-Pasteable-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Copy-Pasteable-Example" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Catalyst, PEtab
# Create the dynamic model(s)
t = default_t()
rn = @reaction_network begin
    @parameters S0 c3=1.0
    @species S(t)=S0
    c1, S + E --&gt; SE
    c2, SE --&gt; S + E
    c3, SE --&gt; P + E
end
speciemap = [:E =&gt; 50.0, :SE =&gt; 0.0, :P =&gt; 0.0]

using ModelingToolkit
using ModelingToolkit: t_nounits as t, D_nounits as D
@mtkmodel SYS begin
    @parameters begin
        S0
        c1
        c2
        c3 = 1.0
    end
    @variables begin
        S(t) = S0
        E(t) = 50.0
        SE(t) = 0.0
        P(t) = 0.0
    end
    @equations begin
        D(S) ~ -c1 * S * E + c2 * SE
        D(E) ~ -c1 * S * E + c2 * SE + c3 * SE
        D(SE) ~ c1 * S * E - c2 * SE - c3 * SE
        D(P) ~ c3 * SE
    end
end
@mtkbuild sys = SYS()

# Observables
@unpack E, S = rn
obs_sum = PEtabObservable(S + E, 3.0)
@unpack P = rn
@parameters sigma
obs_p = PEtabObservable(P, sigma)
observables = Dict(&quot;obs_p&quot; =&gt; obs_p, &quot;obs_sum&quot; =&gt; obs_sum)

# Parameters to estimate
using Distributions
p_c1 = PEtabParameter(:c1)
p_c2 = PEtabParameter(:c2; prior = Normal(10.0, 0.3))
p_s0 = PEtabParameter(:S0)
p_sigma = PEtabParameter(:sigma)
pest = [p_c1, p_c2, p_s0, p_sigma]

# Simulate measurement data with &#39;true&#39; parameters
using OrdinaryDiffEq, DataFrames
ps = [:c1 =&gt; 1.0, :c2 =&gt; 10.0, :c3 =&gt; 1.0, :S0 =&gt; 100.0]
u0 = [:S =&gt; 100.0, :E =&gt; 50.0, :SE =&gt; 0.0, :P =&gt; 0.0]
tspan = (0.0, 10.0)
oprob = ODEProblem(rn, u0, tspan, ps)
sol = solve(oprob, Rodas5P(); saveat = 0:0.5:10.0)
obs_sum = (sol[:S] + sol[:E]) .+ randn(length(sol[:E]))
obs_p = sol[:P] + .+ randn(length(sol[:P]))
df_sum = DataFrame(obs_id = &quot;obs_sum&quot;, time = sol.t, measurement = obs_sum)
df_p = DataFrame(obs_id = &quot;obs_p&quot;, time = sol.t, measurement = obs_p)
measurements = vcat(df_sum, df_p)

model_sys = PEtabModel(sys, observables, measurements, pest)
model_rn = PEtabModel(rn, observables, measurements, pest; speciemap = speciemap)
petab_prob = PEtabODEProblem(model_rn)

# Parameter estimation
using Optim, Plots
x0 = get_startguesses(petab_prob, 1)
res = calibrate(petab_prob, x0, IPNewton())
plot(res, petab_prob; linewidth = 2.0)

ms_res = calibrate_multistart(petab_prob, IPNewton(), 50)
plot(ms_res; plot_type=:waterfall)
plot(ms_res, petab_prob; linewidth = 2.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">WARNING: import of ModelingToolkit.t_nounits into Main conflicts with an existing identifier; ignored.</code></pre><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><div class="citation noncanonical"><dl><dt>[1]</dt><dd><div>F. Fröhlich and P. K. Sorger. <em>Fides: Reliable trust-region optimization for parameter estimation of ordinary differential equation models</em>. PLoS computational biology <strong>18</strong>, e1010322 (2022).</div></dd><dt>[2]</dt><dd><div>A. Raue, M. Schilling, J. Bachmann, A. Matteson, M. Schelke, D. Kaschek, S. Hug, C. Kreutz, B. D. Harms, F. J. Theis and others. <em>Lessons learned from quantitative dynamical modeling in systems biology</em>. PloS one <strong>8</strong>, e74335 (2013).</div></dd><dt>[3]</dt><dd><div>H. Hass, C. Loos, E. Raimundez-Alvarez, J. Timmer, J. Hasenauer and C. Kreutz. <em>Benchmark problems for dynamic modeling of intracellular processes</em>. Bioinformatics <strong>35</strong>, 3073–3082 (2019).</div></dd><dt>[4]</dt><dd><div>H. Wickham. <em>Tidy data</em>. Journal of statistical software <strong>59</strong>, 1–23 (2014).</div></dd><dt>[5]</dt><dd><div>A. F. Villaverde, F. Fröhlich, D. Weindl, J. Hasenauer and J. R. Banga. <em>Benchmarking optimization methods for parameter estimation in large kinetic models</em>. Bioinformatics <strong>35</strong>, 830–838 (2019).</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../petab_simcond/">Simulation conditions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Friday 11 October 2024 08:25">Friday 11 October 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
