<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Adjoint Sensitivity Analysis (Large Models) · PEtab.jl</title><meta name="title" content="Adjoint Sensitivity Analysis (Large Models) · PEtab.jl"/><meta property="og:title" content="Adjoint Sensitivity Analysis (Large Models) · PEtab.jl"/><meta property="twitter:title" content="Adjoint Sensitivity Analysis (Large Models) · PEtab.jl"/><meta name="description" content="Documentation for PEtab.jl."/><meta property="og:description" content="Documentation for PEtab.jl."/><meta property="twitter:description" content="Documentation for PEtab.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom_theme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PEtab.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Extended Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../petab_simcond/">Simulation conditions</a></li><li><a class="tocitem" href="../petab_preeq_simulations/">Steady-State Simulations (Pre-Equilibration)</a></li><li><a class="tocitem" href="../petab_event/">Events (callbacks, dosages, etc.)</a></li><li><a class="tocitem" href="../petab_cond_specific/">Simulation Condition-Specific Parameters</a></li><li><a class="tocitem" href="../petab_obs_noise/">Noise and Observable Parameters</a></li><li><a class="tocitem" href="../import_petab/">Importing PEtab Standard Format</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Parameter Estimation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../pest_method/">Parameter Estimation Methods</a></li><li><a class="tocitem" href="../pest_plot/">Plotting Estimation Results</a></li><li><a class="tocitem" href="../pest_algs/">Available and Recommended Algorithms</a></li><li><a class="tocitem" href="../pest_select/">Model Selection with PEtab-select</a></li><li><a class="tocitem" href="../pest_custom/">Wrapping Optimization Packages</a></li></ul></li><li><a class="tocitem" href="../inference/">Bayesian Inference</a></li><li><a class="tocitem" href="../API/">API</a></li><li><a class="tocitem" href="../grad_hess_methods/">Gradient and Hessian Methods</a></li><li><a class="tocitem" href="../default_options/">Default Options</a></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox" checked/><label class="tocitem" for="menuitem-9"><span class="docs-label">Performance Tips</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../nonstiff_models/">Non-Biology (Non-Stiff) Models</a></li><li><a class="tocitem" href="../Beer/">Condition-Specific Parameters</a></li><li class="is-active"><a class="tocitem" href>Adjoint Sensitivity Analysis (Large Models)</a><ul class="internal"><li><a class="tocitem" href="#Tuning-Options"><span>Tuning Options</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../references/">References</a></li><li><a class="tocitem" href="../FAQ/">FAQ</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Performance Tips</a></li><li class="is-active"><a href>Adjoint Sensitivity Analysis (Large Models)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Adjoint Sensitivity Analysis (Large Models)</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/sebapersson/PEtab.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/sebapersson/PEtab.jl/blob/main/docs/src/Bachmann.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="adjoint"><a class="docs-heading-anchor" href="#adjoint">Adjoint Sensitivity Analysis (large models)</a><a id="adjoint-1"></a><a class="docs-heading-anchor-permalink" href="#adjoint" title="Permalink"></a></h1><p>Having access to the gradient is beneficial for parameter estimation, as gradient-based optimization algorithms often perform best [<a href="../references/#raue2013lessons">2</a>, <a href="../references/#villaverde2019benchmarking">5</a>]. For large model, the most efficient gradient method is adjoint sensitivity analysis [<a href="../references/#frohlich2017scalable">20</a>, <a href="../references/#ma2021comparison">21</a>], with a good mathematical description provided in [<a href="../references/#sapienza2024differentiable">16</a>]. PEtab.jl supports the adjoint sensitivity algorithms in <a href="https://github.com/SciML/SciMLSensitivity.jl">SciMLSensitivity.jl</a>. For these algorithms, three key options impact performance: which algorithm is used to compute the gradient quadrature, which method is used to compute the Vector-Jacobian-Product (VJP) in the adjoint ODE, and which ODE solver is used. This advanced example covers these considerations and assumes familiarity with gradient methods in PEtab (see <a href="../grad_hess_methods/#gradient_support">this</a> page). In addition to this page, further details on tunable options are available in the SciMLSensitivity <a href="https://github.com/SciML/SciMLSensitivity.jl">documentation</a>.</p><p>As a working example, we use a published signaling model referred to as the Bachhman model after the first author [<a href="../references/#bachmann2011division">25</a>]. The Bachmann model is available in the PEtab standard format (a tutorial on importing problems in the standard format can be found <a href="../import_petab/#import_petab_problem">here</a>), and the PEtab files for this model can be downloaded from <a href="https://github.com/sebapersson/PEtab.jl/tree/main/docs/src/assets/bachmann">here</a>. Given the problem YAML file, we can import the problem as:</p><pre><code class="language-julia hljs">using PEtab
path_yaml = joinpath(@__DIR__, &quot;assets&quot;, &quot;bachmann&quot;, &quot;Bachmann_MSB2011.yaml&quot;)
model = PEtabModel(path_yaml)</code></pre><h2 id="Tuning-Options"><a class="docs-heading-anchor" href="#Tuning-Options">Tuning Options</a><a id="Tuning-Options-1"></a><a class="docs-heading-anchor-permalink" href="#Tuning-Options" title="Permalink"></a></h2><p>The Bachmann model is a medium-sized model with 25 species in the ODE system and 113 parameters to estimate. Even though <code>gradient_method=:ForwardDiff</code> performs best for this model (more on this below), it is a good example for showcasing different tuning options. In particular, when computing the gradient via adjoint sensitivity analysis, the key tunable options for a <code>PEtabODEProblem</code> are:</p><ol><li><code>odesolver_gradient</code>: Which ODE solver and solver tolerances (<code>abstol</code> and <code>reltol</code>) to use when solving the adjoint ODE system. Currently, <code>CVODE_BDF()</code> performs best.</li><li><code>sensealg</code>: Which adjoint algorithm to use. PEtab.jl supports the <code>InterpolatingAdjoint</code>, <code>QuadratureAdjoint</code>, and <code>GaussAdjoint</code> methods from SciMLSensitivity. For these, the most important tunable option is the VJP method, where <code>EnzymeVJP</code> often performs best. If this method does not work, <code>ReverseDiffVJP(true)</code> is a good alternative.</li></ol><p>As <code>QuadratureAdjoint</code> is the least reliable method, we here explore <code>InterpolatingAdjoint</code> and <code>GaussAdjoint</code>:</p><pre><code class="language-julia hljs">using SciMLSensitivity, Sundials
osolver = ODESolver(CVODE_BDF(); abstol_adj = 1e-3, reltol_adj = 1e-6)
petab_prob1 = PEtabODEProblem(model; gradient_method = :Adjoint,
                              odesolver = osolver, odesolver_gradient = osolver,
                              sensealg = InterpolatingAdjoint(autojacvec = EnzymeVJP()))
petab_prob2 = PEtabODEProblem(model; gradient_method = :Adjoint,
                              odesolver = osolver, odesolver_gradient = osolver,
                              sensealg = GaussAdjoint(autojacvec = EnzymeVJP()))</code></pre><p>Two things should be noted here. First, to use the adjoint functionality in PEtab.jl, SciMLSensitivity must be loaded. Second, when creating the <code>ODESolver</code>, <code>adj_abstol</code> sets the tolerances for solving the adjoint ODE (but not the standard forward ODE). From our experience, setting the adjoint tolerances lower than the default <code>1e-8</code> improves simulation stability (gradient computations fail less frequently). Given this, we can now compare runtime:</p><pre><code class="language-julia hljs">using Printf
x = get_x(petab_prob1)
g1, g2 = similar(x), similar(x)
petab_prob1.grad!(g1, x)
petab_prob2.grad!(g2, x)
@printf(&quot;Runtime InterpolatingAdjoint: %.1fs\n&quot;, b1)
@printf(&quot;Runtime GaussAdjoint: %.1fs\n&quot;, b2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Runtime InterpolatingAdjoint: 950.4s
Runtime GaussAdjoint: 1637.3s</code></pre><p>In this case <code>InterpolatingAdjoint</code> performs best (this can change dependent on computer). As mentioned above, another important argument is the VJP method; let us explore the best two options for <code>InterpolatingAdjoint</code>:</p><pre><code class="language-julia hljs">petab_prob1 = PEtabODEProblem(model; gradient_method = :Adjoint,
                              odesolver = osolver, odesolver_gradient = osolver,
                              sensealg = InterpolatingAdjoint(autojacvec = EnzymeVJP()))
petab_prob2 = PEtabODEProblem(model; gradient_method = :Adjoint,
                              odesolver = osolver, odesolver_gradient = osolver,
                              sensealg = InterpolatingAdjoint(autojacvec = ReverseDiffVJP(true)))
b1 = @elapsed petab_prob1.grad!(g1, x)
b2 = @elapsed petab_prob2.grad!(g2, x)
@printf(&quot;Runtime EnzymeVJP() : %.1fs\n&quot;, b1)
@printf(&quot;Runtime ReverseDiffVJP(true): %.1fs\n&quot;, b2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Runtime EnzymeVJP() : 911.6s
Runtime ReverseDiffVJP(true): 0.4s</code></pre><p>In this case, <code>ReverseDiffVJP(true)</code> performs best (this can vary depending on the computer), but often <code>EnzymeVJP</code> is the better choice. Generally, <code>GaussAdjoint</code> with <code>EnzymeVJP</code> is often the best combination, but as seen above, this is not always the case. Therefore, for larger models where runtime can be substantial, we recommend benchmarking different adjoint algorithms and VJP methods to find the best configuration for your specific problem.</p><p>Lastly, it should be noted that even if <code>gradient_method=:Adjoint</code> is the fastest option for larger models, we still recommend using <code>:ForwardDiff</code> if it is not substantially slower. This is because computing the gradient via adjoint methods is much more challenging than with forward methods, as the adjoint approach requires solving a difficult adjoint ODE. In our benchmarks, we have observed that sometimes <code>:ForwardDiff</code> successfully computes the gradient, while <code>:Adjoint</code> does not. Moreover, forward methods tend to produce more accurate gradients.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><div class="citation noncanonical"><dl><dt>[2]</dt><dd><div>A. Raue, M. Schilling, J. Bachmann, A. Matteson, M. Schelke, D. Kaschek, S. Hug, C. Kreutz, B. D. Harms, F. J. Theis and others. <em>Lessons learned from quantitative dynamical modeling in systems biology</em>. PloS one <strong>8</strong>, e74335 (2013).</div></dd><dt>[5]</dt><dd><div>A. F. Villaverde, F. Fröhlich, D. Weindl, J. Hasenauer and J. R. Banga. <em>Benchmarking optimization methods for parameter estimation in large kinetic models</em>. Bioinformatics <strong>35</strong>, 830–838 (2019).</div></dd><dt>[16]</dt><dd><div>F. Sapienza, J. Bolibar, F. Schäfer, B. Groenke, A. Pal, V. Boussange, P. Heimbach, G. Hooker, F. Pérez, P.-O. Persson and others. <em>Differentiable Programming for Differential Equations: A Review</em>, arXiv preprint arXiv:2406.09699 (2024).</div></dd><dt>[20]</dt><dd><div>F. Fröhlich, B. Kaltenbacher, F. J. Theis and J. Hasenauer. <em>Scalable parameter estimation for genome-scale biochemical reaction networks</em>. PLoS computational biology <strong>13</strong>, e1005331 (2017).</div></dd><dt>[21]</dt><dd><div>Y. Ma, V. Dixit, M. J. Innes, X. Guo and C. Rackauckas. <em>A comparison of automatic differentiation and continuous sensitivity analysis for derivatives of differential equation solutions</em>. In: <em>2021 IEEE High Performance Extreme Computing Conference (HPEC)</em> (IEEE, 2021); pp. 1–9.</div></dd><dt>[25]</dt><dd><div>J. Bachmann, A. Raue, M. Schilling, M. E. Böhm, C. Kreutz, D. Kaschek, H. Busch, N. Gretz, W. D. Lehmann, J. Timmer and others. <em>Division of labor by dual feedback regulators controls JAK2/STAT5 signaling over broad ligand range</em>. Molecular systems biology <strong>7</strong>, 516 (2011).</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Beer/">« Condition-Specific Parameters</a><a class="docs-footer-nextpage" href="../references/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 15 August 2025 10:25">Friday 15 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
